新生代收集器：Serial,ParNew,Parallel Scavenge
老年代收集器：Serial Old,Parallel Old,CMS
整堆收集器：G1
Serial回收器：串行回收
Serial收集器采用复制算法，串行回收，STW机制的方式执行内存回收
除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器
Serial Old收集器同样也采用了串行回收和STW，只不过内存回收算法使用的是标记-压缩算法
Serial Old 是运行在Client模式下默认的老年代的垃圾回收器
Serial Old在Server（客户端）模式主要有两个用途：
与新生代的Parallel Scanvenge配合使用
作为老年代CMS收集器的后备垃圾收集方案

Serial收集器（单线程、复制算法）串行回收
（串行指的是垃圾回收线程串行，单线程）
这个收集器是一个单线程的收集器，但它的单线程意义不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作
更重要的是在它进行垃圾收集时，必须要暂停其他所有的工作线程，直到它收集结束
优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心
做垃圾收集自然可以获得最高的单线程收集效率
运行在Client模式下的虚拟机是个不错的选择
这种垃圾回收器了解一下就可以，现在已经不用串行的了，而且在限定单核cpu才可以使用，现在都不是单核的了
对于交互强的应用而言，这种垃圾收集器是不能接受的，一般在Java web应用程序中是不会采用串行垃圾收集器的
是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。

Serial Old 收集器（单线程标记压缩算法 ）
Serial Old 是 Serial 垃圾收集器年老代版本
也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。
在 Server 模式下，主要有两个用途：
1. 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。
2. 作为年老代中使用 CMS 收集器的后备垃圾收集方案。

ParNew 垃圾收集器（Serial+多线程）
ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，
其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。
是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器

Parallel Scavenge 收集器（多线程复制算法、高效）
和ParNew收集器不同，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器
自适应调节策略也是Parallel Scavenge与ParNew一个重要区别
动态调整内存的分配情况，以达到一个最优的目的，如：希望吞吐量优先，还是希望低延迟，达到一个最优策略
高吞吐量适合后台运行的，如批量处理，订单处理，工资支付
Java8中默认是此垃圾回收器
jdk9中默认就是G1
-xx:MaxGCPauseMillis 设置垃圾回收器最大停顿时间（stw），单位毫秒
为了尽可能地把停顿时间控制在MaxGCPauseMillis以内，收集器在工作时会调整java堆大小或者其他一些参数
对用户来讲，停顿时间越短体验越好，但是在服务器端，我们注重高并发，整体的吞吐量，所以服务器端适合Parallel,进行控制
这个参数使用要谨慎
-xx:GCTimeRatio:垃圾回收时间占总时间的比例（1/(N+1)）,用于衡量吞吐量的大小
取值范围（1,100），默认值99，就就是垃圾时间不超过1%
与前一个参数:-xx:MaxGCPauseMillis参数有一定矛盾性，暂停时间越长，Radio参数就容易超过设定的比例
-xx:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器应用自适应调节策略
在这种模式下，年轻代的大小，Eden和Survivor的比例，晋升老年代的对象的年龄成参数就会被自动调整，以达到堆大小，吞吐量和
停顿时间之间的平衡点  

Parallel Old 收集器（多线程标记整理算法）
Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。
在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，
只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，
如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。

CMS 收集器（多线程标记清除算法）低延迟
jdk1.5推出
无法与1.4中已经存在的新生代收集器Parallel Scavenge配合工作，
所以在1.5中用CMS收集老年代的时候，新生代只能选Serial或者ParNew中的一个
它第一次实现了让垃圾收集线程与用户线程同时工作
它的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，挺短时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验
Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间
和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。
最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。

初始标记阶段
所有工作线程stw，这个阶段主要任务仅仅是标记出GC Roots能直接关联到的对象，
一旦标记完成，就会恢复被暂停的所有应用线程
由于直接关联对象比较小，所以这里的速度非常快

并发标记
从GC Roots的直接关联对象开始遍历整个对象图的过程，
这个过程耗时较长，但是不需要停顿用户线程，可以与垃圾回收线程一起并发运行

重新标记
由于并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行
因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记的时间短

（并发标记阶段，在遍历GCRoots时,用户线程也在执行，若此时遍历过的一个对象发现没有引用，
但由于用户线程并发执行，这期间可能导致遍历过的这个对象又被其他对象引用，
所以才需要重新标记阶段再遍历一遍看有没有漏标记的对象，否则就会导致被重新引用的对象被误清理掉）
有肯能有漏标记的对象，也有可能有的对象在并发执行过程中变成垃圾

并发清除
清理删除掉标记阶段判断的已经死亡的对象，释放内存空间
由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

CMS
优点：
低延迟
垃圾线程与用户线程并发执行
缺点：
1.基于标记-清除算法，容易产生大量内存碎片，用户线程可用的空间不足，在无法分配大对象的前提下，不得不提前触发FULL GC
2.对CPU资源占用比较多，可能因为占用一部分CPU资源（垃圾回收占用了一部分线程）导致应用程序响应变慢
3.无法处理浮动垃圾
浮动垃圾：
在并发清除阶段，用户程序继续运行，可能产生新的内存垃圾，这一部分垃圾出现在标记过程之后，因此，CMS无法清除。这部分垃圾称为“浮动垃圾“
CMS无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的空间

可设置的参数
-XX:+UseCMSCompactAtFullCollection 执行完Full GC对内存空间进行压缩整理
-XX:CMSFullGCBeforeCompaction 设置在执行多少次Full GC后对内存空间进行压缩整理
-XX:ParallelCMSThreads 设置CMS的线程数
CMS默认启动的线程数是（ParallelGCThreads+3）/4
ParallelGCThreads 是年轻代并行收集器的线程数，当cpu资源比较紧张时，受到CMS 收集线程的影响，
应用程序的性能在垃圾回收阶段可能会非常糟糕

-XX:CMSInitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收
jdk以前默认值68%，jdk6以后默认值为92%
如果内存增长缓慢，可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率
减少老年代回收的次数可以较为明显地改善应用程序性能
反之，如果应用程序内存使用率增长很快（垃圾回收的线程相对慢一些，数值调小一点，及时回收垃圾，很容易出现CMS Failure的情况，不得不去调用串行收集器），则应该降低这个阈值，以避免频繁触发老年代 串行收集器
因此，通过该参数可以有效降低Full GC的次数

小结
如果想要最小化地使用内存和并行开销，请选Serial GC
如果想要最大化应用程序的吞吐量，请选Parallel GC
如果想要最小化GC的中断或停顿时间，请选CMS GC

jdk9把CMS弃用了，14彻底删除了


------------------G1 收集器------------------
背景：为了适应现在不断扩大的内存和不断正价的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量
官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量

为什么叫G1？
1.因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）,
使用不同的Rigion来表示Eden,幸存者0区，幸存者1区，老年代等。
2.G1 GC有计划地避免在真个Java堆进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小，
（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，
优先回收价值最大的Region
3.由于这种方式的侧重点在于回收垃圾 最大量的区间，所以叫垃圾优先:Garbage First
主要针对配备多核cpu及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征

相比与 CMS 收集器，G1收集器两个最突出的改进是：
1. 基于标记-整理算法，不产生内存碎片。
2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，
同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。
区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。

jdk1.7正式启用，不是1.8的默认，需要使用-xx:UseG1GC来启用

G1回收器的特点（优势）
----并行与并发----
并行性：G1回收期间，可以有多个gc线程同时工作，有效利用多核计算能力
并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，
因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

----分代收集----
1.从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代，老年代，年轻代依然有Eden和Survivor区
但从堆的结构上看，它不要求整个Eden区，年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量
2.将堆空间分为若干个区域，这些区域中包含了逻辑上年轻代和老年代
3.和之前的各类回收器不同：它同时兼顾年轻代和老年代

----空间整合----
CMS:标记清除算法，内存碎片，若干次GC后进行一次碎片整理
G1将内存划分为一个个的region，内存的回收是以region作为基本单位的
region之间是复制算法，但整体上实际可以看作是标记压缩算法，两种算法都可以避免内存碎片
这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC
尤其是当Java堆非常大的时候，G1的优势更加明显
（在有限的时间内回收价值比较高的堆）
region复制算法：一个region中存了很多数据，如果要回收，会判断里面哪些数据还有用，有用的数据通过复制算法
复制到相应的另外的region中

----可预测的停顿时间模型----
这是G1相当于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型
能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒
1.由于分区的原因，G1可以只选取部分区域进行内存回收，
这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制
2.G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值）
在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region
这保证了G1收集器在有限的时间内可以获取尽可能高的收集效率
3.相比于CMS GC,G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多

缺点：
相较于CMS，G1还不具备全方位，压倒性优势，比如在用户程序运行过程中，
G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高
从经验来说，在小内存应用上CMS的表现大概率会优于G1,而G1在大内存应用上则发挥其优势，平衡点在6-8G之间
G1有10%-20%的额外空间占用

G1主要适合大堆，大堆回收要尽量避免全堆的扫描，引人记忆集(Remember)

主要回收细节
年轻代GC
年轻代GC+并发标记过程
混合回收
Full GC

G1的参数设置
-XX:+UseG1GC jdk9以前需要指定使用G1
设置每个region的代销，值是2的幂，范围是1mb-32mb
设置期望达到的最大GC停顿时间指标，默认是200ms
设置触发并发GC周期的Java堆占用率阈值

调优
常用参数：
1.设置内存的时候：堆，方法区
2.垃圾回收环节设置一些参数