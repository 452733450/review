如何确定垃圾
1.引用计数算法
对每个对象保存一个整型的引用计数属性，用于记录对象被引用的情况
缺点：
需要单独的字段存储计数器，增加了存储空间的开销
每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销
致命缺陷：无法处理循环引用
Python如何解决循环引用
手动解除：在合适的时机，解除引用关系
使用weakref，weakref是Python提供的标准库，旨在解决循环引用

2.可达性分析算法（解决循环引用）
GC Roots根集合就是一组必须活跃的引用
可达性分析算法是以根对象集合为起点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达
使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链
如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象
在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象

GC Roots包括以下几类元素
虚拟机栈中引用的对象，如：各个线程中被调用的方法中使用到的参数，局部变量等。
本地方法栈内JNI（通常说的本地方法）引用的对象
方法区中静态变量引用的对象，如：Java类的引用类型静态变量
方法区中常量引用的对象，如字符串常量池里的引用
所有被同步锁synchronized持有的对象
Java虚拟机内部的引用，
如：基本数据类型对应的Class对象，一些常驻的异常对象（NullPointerException，OutOfMemoryError）,系统类加载器

如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行，
这点不满足的话分析结果的准确性就无法保证
这点也导致GC进行时必须“Stop The World”的一个重要原因
即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的

finilization机制允许开发人员对象被销毁之前的自定义处理逻辑
垃圾回收对象之前，总会先调用这个对象的finalize（）方法
finalize（）允许在子类被重写，用于在对象被回收时进行资源释放。
通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件，套接字和数据库连接等

垃圾回收算法
1.标记清除算法
标记：垃圾收集器从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的Header中记录为可达对象
清除：垃圾收集器对堆内存从头到尾进行线性的遍历，如果发现某个对象在Header中没有标记为可达对象，则将其回收
缺点：
效率不算高
这种法师清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表
何为清除？
这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对戏需要加载时，
判断垃圾的位置的空间是否足够，如果够，就存放

2.复制算法
背景：
为了解决标记-清除算法在垃圾收集效率方面的缺陷
核心思想：
将活着的内存空间分为两块每次只使用其中一块，在垃圾回收完成将使用中的内存中的活着的对象复制到未被使用的
内存中去，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
优点：
没有标记和清除过程，实现简单，运行高效
复制过去以后保证空间的连续性，不会出现碎片问题
缺点：
最大的问题是可用内存被压缩到了原本的一半，且存活对象增多的话，复制算法的效率会大大降低
对于G1这种拆分为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，
不管是内存占用或者时间开销也不小

3.标记压缩算法
背景：
复制算法的高效性是建立在存活对象少，垃圾对象多的前提下的，这种情况在新生代经常发生，
但是在老年代，更常见的情况是大部分都是存活对象，如果依然使用复制算法，由于存活对象较多，复制的成本也将很高
因此，基于老年代垃圾回收的特性，需要使用其他的算法
标记清除算法如果用在老年代，不仅效率低下，而且会产生内存碎片

执行过程：
第一阶段和标记清除算法一样，从根节点开始标记所有被引用的对象
第二阶段将所有的存活对象压缩（复制过去）到内存的一端，按顺序排放
之后，清理边界外所有的空间

优点：
消除了标记清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，jvm只需要维持一个内存的起始地址即可
消除了复制算法当中，内存减半的高额代价
缺点：
从效率上来说，标记压缩算法是要低于复制算法的
移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
移动过程中，需要STW

4.分代收集算法
不同对象的生命周期是不一样的
因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率
年轻代使用复制算法
年轻代特点：区域相对老年代较小，对象生命周期短，存活率低，回收频繁
用survivor来缓解内存利用率不高的问题
老年代特点：区域较大，对象生命周期长，存活率高，回收不及年轻代频繁
这种情况存在大量存活率高的对象，复制算法明显不合适，一般是由标记清除和标记压缩算法混合实现
标记阶段的开销与存活对象的数量成正比
清除阶段的开销与所管理区域的大小成正比
压缩阶段的开销与存活对象的数据成正比

5.分区收集算法
一般来说，在相同条件下，堆空间越大，一次GC所需要的时间越长，GC产生的停顿也越长，
为了更好地控制GC产生的停顿时间
分区算法将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收
这样做的好处是根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿

内存溢出：
javadoc对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存
首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够，原因有二：
Java虚拟机的堆内存设置不够
通过-Xms,-Xmx调整
代码中创建了大量对象，并且长时间不能被垃圾收集器收集（存在被引用）

在抛出OOM之前，通常垃圾回收器会被触发，尽其所能去清理出空间
如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象
当然，也不是在任何情况下GC都会被触发
如：我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾回收并不能解决这个问题，就直接OOM

内存泄漏
栈中存在堆中对象的引用,但是这个对象数据后期不再使用了，但是gc又不能回收，多了就导致内存泄漏（内存被无用的东西占用了）
严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏
尽管内存泄漏不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会逐步被蚕食，直至耗尽所有内存
最终出现OOM，导致程序崩溃
1.单例模式
单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的
则会导致内存泄漏的产生
一些提供close的资源未关闭导致内存泄漏
数据库连接，socket连接，io连接必须手动close，否则是不能被回收的

强引用：不回收
弱引用：内存不足时回收
软引用：发生GC时就回收
虚引用：对象被回收时收到一个系统通知