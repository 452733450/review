12. JVM的程序计数器作用，是线程私有的吗
13. 谈谈JVM的内存模型
jvm的cms和g1垃圾回收机制有什么区别
.java是通过什么编译的，又是如何在jvm中运行的
Javac编译器读取baiJava源代码，并将其编译成du字节代码
2.jvm内存模型
11.jvm中一个gc一个对象时有哪些算法，把你知道的都说出来
谈谈JVM GC
双亲委派机制
JVM有看过吗 GC sort GC算法
jvm的内存结构
17.jvm加载类的机制
22.jvm中内存溢出
23.讲讲堆和栈
24.gc是什么  垃圾回收是什么原理 有什么好处 你知道哪几种回收机制
25.内存泄漏了怎么办
用 什么命令查看jvm 里的线程的运行情况
.jvm的调优参数有哪些
1.jvm内存?
2.类加载机制
----------什么时候容易发生内存溢出----------
1.无限递归-栈溢出
-递归没有跳出条件
2.jvm参数设置极其不合理-堆溢出
-初始堆容量
-最大堆容量
12. JVM内存溢出，谈谈 ？
JVM中一个对象从年轻代到老年代的过程和条件，几种，几次gc算法
CMS和G1区别特点
说说java内存模型，新生代老年代算法，你说的新生代老年代属于堆还是栈，还知道哪些gc算法，
创建大对象也是在新生代分配吗，（
答：直接晋升进入老年代，问：具体多大对象，答：超过eden区大小，问：你是否确定，顿时虚了，
后来回去查阅过，我回答的不对，jvm这里的看点很多，涉及到优化）。
新生代的算法，说说minor gc,minor gc触发条件。老年代用了什么算法，说说标记整理算法，full gc是否真正回收了废弃对象。有哪些gc策略。
你觉得你的项目中如果需要jvm调优你会注重哪个分带的调优，或者说更注重哪种gc调优，为什么，具体怎么做（懵逼，随便吹了下。问：你确定吗？ 顿时又虚了）。
JVM运行时数据区
jvm内存模型
JVM调优
jvm调优
56.  2、jvm内存模型，要求说的比较细和深入
jvm堆里面伊甸园
堆里面gc是怎么回收内存的
栈里面内存是怎么回收的


--------------栈和堆--------------
栈是运行时的单位，堆是存储的单位
栈解决程序运行时的问题，即程序如何执行，数据如何处理
堆解决的是数据存储的问题，即数据放哪，怎么放


--------------类加载机制--------------
类加载分为3个阶段
加载，连接（验证，准备，解析），初始化

加载：
根据类的全限定名，获取代表该类的二进制字节流
将这个字节流所代表静态存储结构转化为方法区的运行时数据结构
在内存中创建一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

验证：
确保Class文件的字节流中的信息符合当前虚拟机的要求，且不会危及虚拟机自身的安全

准备：
为类变量分配内存并设置初始值，在初始化阶段设置真正的值，类加载器<clinit>
final修饰的static不包括，final修饰的在编译期间就分配了
也不会为实例变量分配初始化，会随着对象一起分配到堆中

解析：
将常量池内的符号引用转换为直接引用的过程
符号引用就是一组符号来描述所引用的目标
解析动作主要针对类或接口，字段，类方法，接口方法，方法类型等

初始化：
初始化阶段就是执行类构造器方法<clinit>()的过程
此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
构造器方法中指令按照语句在源文件中出现的顺序执行
若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕

双亲委派机制
如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行
如果父类加载器上面还存在父类加载器，则进一步向上委托，依次递归，请求最终到达顶层的启动类加载器
如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子类加载器会
尝试自己去加载，这就是双亲委派模式
优势：
避免了类的重复加载
保护程序安全，防止核心API被随意篡改
就不能随便乱定义类，如:java.lang.String,java.lang.shagketg


--------------jvm内存模型--------------
1.程序计数器
一块较小的内存空间，是当前线程执行的字节码的行号指示器
*程序计数器是用于存放下一条指令所在单元的地址的地方。(百度百科)
记录当前指令的地址，线程私有，也是虚拟机规范中唯一没有outOfMemoryError情况的区域
为何线程私有？
由于cpu时间片限制，众多线程在并发执行过程中，
任何一个确定的时刻，一个单核处理器或者多核处理的一个内核，只会执行某个线程中的一条指令
这样就必然导致经常中断或恢复
cpu需要不停地切换各个线程，切换回来以后，就得知道从哪里继续执行

2.虚拟机栈
是描述java方法执行的内存模型
每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的java方法调用，线程私有
每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。
栈存在OOM，不存在垃圾回收，因为他只有进栈出栈的操作(先进后出，后进先出)
    栈帧
        局部变量表
            定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，
            这些数据类型包括各类基本数据类型、对象引用以及返回值类型
            局部变量表所需的容量大小是在编译期确定下来的
            局部变量表最基本的存储单位是Slot（变量槽），32位以内（int，float）的内省占用一个slot，64位的类型(long和double)占2个Slot
            引用类型也是32位
            byte,short,char在存储钱被转换为int，boolean也转换为int
            JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功方位到局部变量表中指定的局部变量值
            一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表的每一个slot上
            如果当前栈帧是由构造方法或者实例方法（非静态方法）创建的，那么该对象引用的this将会存放在index为0的slot处
            其余的参数按照参数表顺序继续排列
            代码中静态方法中是不可以引用this的，因为this不存于当前方法的局部变量表中，不存在还怎么引用，因为是静态方法是依赖于类的
            非静态方法中，要调用这个方法，首先要new出这个对象，这样实例方法的局部变量表中就有了this
            局部变量表中的变量也是重要的垃圾回收跟节点(GC Roots),只要是被局部变量表中直接或间接引用的对象都不会被回收
        操作数栈
            操作变量的内存模型
            在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)
            某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈
            比如：执行复制，交换，求和等操作
            操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
        动态链接（或指向运行时常量池的方法引用）
            每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接
            类在加载过程中使用到的信息都作为一个符号声明出来，然后具体在各个方法中想用谁，就用这个符号来指明
            在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里
            比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用
            转换为调用方法的直接引用
            字节码文件中的常量池，运行起来后，就放到方法区了，就叫做运行时常量池
            *相当于在栈帧中存储了一些地址，这些地址指向谁，就是方法区中的运行时常量池
            *常量池的作用，就是为了提供一些符号和常量，便于指令的识别，同时使得占用空间比较小，调用起来直接指针指向一下
            调用起来会比较方便
            每个栈帧可以共享这些符号引用，并放在方法区中，栈的占用内存就小了
        方法返回地址
            存放调用该方法的pc寄存器的值
            一个方法的结束，有两种方式：
            正常执行完成
            出现未处理的异常，非正常退出
            无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置
            方法正常退出时，调用者的pc寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址
            而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息
        一些附加信息
            栈帧中还允许携带与Java虚拟机实现相关的一些附加信息，例如，对程序调试提供支持的信息

3.本地方法栈
    Java虚拟机栈是用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
    本地方法栈也是线程私有的
    调的是C相关的方法
    Thread.start()里面有个start0()方法是native的，是由C来实现的
    使用native关键字修饰的方法就是本地方法
    为什么要用native，因为有些层次的任务用Java实现起来不容易，对效率又特别在意时

4.堆
    方法和堆对进程来说各自是唯一的，一个进程就对应着一个jvm的实例
    是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行
    垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以
    细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代
    新生代与永久代1：2,如果生命周期比较长，建议把老年代调大一些
    Eden:Survivor 8:1:1
    面试题：jdk1.8中内存主要有哪些变化，主要就是堆空间的变化（永久代变为元空间）
    老年区满了就会进行fullGC,被引用的对象不能回收，就会OOM
    新生代使用复制清除算法
    采用标记-整理算法（mark-compact），原因是老年代每次GC只会回收少部分对象。
    Perm（永久代）：用来存储类的元数据，也就是方法区。
    在jdk1.8中，Perm被替换成MetaSpace，MetaSpace存放在本地内存中。原因是永久代经常内存不够用，或者发生内存泄漏。
    元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。

5.方法区
    元空间就是方法区的落地实现
    用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等
    1.线程共享的
    2.运行时常量池：
    是方法区的一部分
    存放编译期生成的各种字面量和符号引用
    Class文件中除了存有类的版本、字段、方法、接口等描述信息，还有一项是常量池，存有这个类的 编译期生成的各种字面量和符号引用，
    这部分内容将在类加载后，存放到方法区的运行时常量池中。

方法区放的：类信息，枚举类，注解，接口等等，这些也统称为类信息，也可以叫类型信息，
另一个重要的就是运行时常量池，不同的jdk，字符串常量池存放的位置会有一定的变化
类加载器把字节码文件中的类信息加载到方法区，字节码文件中的常量池加载到方法区以后，对应的结构就叫做运行时常量池
常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型

运行时常量池就是字节码文件中每一个类或接口对应的常量池表的表示形式（在运行时）
jdk6之前字符串常量池，静态变量是放在方法区中，永久代是方法区的落地实现
jdk7后将StringTable(字符串常量池)，静态变量放到了堆空间
永久代只有fullGC是才会回收，导致回收效率低，开发中会有大量字符串被创建，放到堆里，能及时回收内存

内存泄漏：栈中存在堆中对象的引用,但是这个对象数据后期不再使用了，但是gc又不能回收，多了就导致内存泄漏（内存被无用的东西占用了）
通过工具对堆转存储快照进行分析，确认内存中的对象是否是必要的,(JProfiler)