https://www.jianshu.com/p/67f4d12c0400
CAS通过调用JNI的代码实现的。JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言。
而compareAndSwapInt就是借助C来调用CPU底层指令实现的。程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。
如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。
反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。

2.处理器如何实现原子操作？
    首先处理器能自动保证基本的内存操作是原子性的。表示当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。
    但是对于复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。
    但是，处理器提供了总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

3.总线锁定和缓存锁定
     －1）使用总线锁保证原子性
          第一机制是通过总线锁保证原子性。
          处理器使用总线锁就是来解决这个问题的。
          所谓总线锁就是使用处理器提供的一个LOCLK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
      －2）使用缓存锁保证原子性
            第二机制是通过缓存锁定来保证原子性
            在同一时刻，只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，
            这使得锁定期间，其它处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，
            目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

            所谓缓存锁定是指C P U对缓存行进行锁定，当缓存行中的共享变量回写到内存时，
            其他C P U会通过总线嗅探机制感知该共享变量是否发生变化，
            如果发生变化，让自己对应的共享变量缓存行失效，重新从内存读取最新的数据，
            缓存锁定是基于缓存一致性机制来实现的，因为缓存一致性机制会阻止两个以上C P U同时修改同一个共享变量（现代C P U基本都支持和使用缓存锁定机制）。

