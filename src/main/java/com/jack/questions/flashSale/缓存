秒杀活动列表接口
秒杀详情接口
秒杀品列表接口
秒杀品详情接口

在单机视角下，我们可以看到本地缓存如何与分布式缓存进行交互。
只有在本地缓存不存在或失效时，当前线程才会请求远程缓存，并且在同一时刻只有一个线程可以执行本地缓存的更新，这种设计也是出于最大限度降低远程IO的考虑。

需要注意的是，在本地缓存失效且当前线程未能获得更新本地缓存的机会时，当前线程需要立即返回而不是原地阻塞等待
那么这种情况就需要客户端进行适配，即在本次请求未能获得数据时应当静默处理，既不提示错误也不要刷新本地数据，稍后再试即可。

在对本地缓存技术选型时，我们选择了Guava中的Cache，它是一款比较优秀的缓存框架，足够的简单易用，支持LRU的ConcurrentHashMap，
并提供了基于容量、时间和弱引用等多种缓存回收方式。
除此之外，Spring也提供了缓存方案，
    两者不同之处在于前者是独立的组件库（Library），后者是与Spring深度耦合的框架（Framework），在非必要的情况我们建议选择组件库。

LoadingCache < String, FlashItemCache > itemCache =
    CacheBuilder.newBuilder()
    .maximumSize(100) // 设置最大只能缓存100条数据
    .expireAfterAccess(30, TimeUnit.MINUTES) // 设置数据将在访问后的30分钟内过期
    .build(new CacheLoader < String,FlashItemCache > () { // 缓存数据加载方式
        @Override
        public FlashItemCache load(Long itemId) throws Exception {
            return getFromDatabase(itemId);
        }
    });
FlashItemCache flashItemCache = itemCache.get("foo-item-id"); // 读取缓存中的数据
你看，Guava Cache的使用方式就是这样的简单、优雅，借助于链式调用，我们可以很方便地设置过期时间、容量以及数据的加载方式。

2. 缓存生命周期
基于前述的缓存设计原则和Guava Cache的技术特点，FlashSale中使用的本地缓存容量默认为10，过期时间为5秒。结合业务规则，目前本地缓存的刷新机制有2种：
被动更新：本地缓存过期后被驱逐；
主动更新：请求传入的版本号大于本地缓存的版本号，意味着本地缓存的数据滞后，需要从分布式缓存中重新获取

需要注意的是，分布式缓存在刷新的过程中，并不会主动刷新所有服务器上的本地缓存，本地缓存将遵循单机的刷新策略。
这意味着，本地缓存可能会有秒级或毫秒级的滞后，
对于数据一致性非绝对敏感的场景，这种短时间的延迟下的脏数据是可以接受的，它只是会对用户侧的展示有所影响，而不会影响到服务端的数据状态。

当然，我们也可以采取一些诸如事件广播的方式在第一时间更新所有机器的缓存
但是，这种方式也并非完美，一方面我们需要引入消息机制，这会增加系统的复杂度；
而另一方面，在高并发的情况下，这种方式也只不过是降低了数据的延迟，各服务器之间仍然会存在少许的差异，比如消息到达时间、处理时间等。
因此，在综合评估的情况下，如非必要应首选轻量级的方案。

（四）数据一致性保证
如何保证缓存与数据库数据的一致性？
如何保证本地缓存与分布式缓存的一致性？
我们几乎很难在保证高性能的同时，也保证数据的绝对新鲜。
所以，我们要退而求其次，不在缓存层面追求数据的强一致性，而当我们把缓存定性为弱一致性时，问题即刻迎刃而解。
对于强一致性的保证，我们把这个难题交给数据库约束+业务规则约束+补偿机制，通过业务规则结合数据库自带的约束机制来实现强一致性的目的。
缓存之所以为缓存，就在于我们对缓存的数据延迟有一定的忍耐度，在合理范围内的延迟是可以接受的。
因此，在保证数据库最终一致的情况下，我们允许本地缓存和分布式缓存有秒级或毫秒级的延迟。
当然，我们要尽可能地降低缓存的延迟，以提高用户体验。

exist表示当前数据是否存在，而不是缓存是否存在。比如ID为1的秒杀品不存在，但是缓存会存在，并且exist的值为false，
    但应用层拿到缓存结果并且exist=false时，就知道这个数据不存在，可以返回NOT FOUND之类的错误；
later表示缓存正在更新中，请客户端稍后再试，这个机制需要客户端配合实现，不要报错。
    前面我们说过只允许一个线程更新缓存，那么在这个过程中，其他线程进来后不能让这些线程等待，
    等待的线程会给系统资源带来负担，所以我们不要让它们等，而是让它们直接先回去。


1.为啥更新本地缓存的时候还需要加一个锁啊？guava的本地缓存组件不是本来就是线程安全的吗？
两个原因：一是降低不必要的计算和重复赋值，
二是guava底层是线程安全，但它是阻塞设计。在并发系统中，阻塞设计是极其危险的存在，非必要应极力避免。