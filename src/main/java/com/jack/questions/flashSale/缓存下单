下单加一个用户id的分布式锁(加锁成功后进入)用户下单时必须获得对应的锁，防止因抖动等导致重复下单
普通下单，下单的时候去查一下缓存里的库存
    下单规则校验
    获取库存缓存
        先获取商品详情缓存（为了看商品数据是否存在，商品不存在，都没必要去获取库存了）
        获取库存缓存，跟其他缓存获取的逻辑一样，先从本地拿，本地没有去分布式缓存拿，分布式缓存没有去数据库拿
             更新商品缓存的最新库存(获取剩余库存，本地没有，就去分布式缓存拿，拿到之后再更新到本地缓存里)
        雪花算法生成唯一id
        库存预扣减(redis)
        redis扣成功去数据库扣减
        数据库扣减成功、下单(创建订单)
        订单保存成功之后，发布领域事件
        一旦数据库操作发生任何异常，在catch里面恢复redis里的库存(预扣库存恢复失败)
取消订单
用户在执行取消动作时，必须先获得锁，防止抖动等造成重复取消；
取消过程包括三个关键步骤：
将订单置为取消状态；
恢复秒杀品中的库存；
恢复库存缓存中的库存。
取消订单时如果出现库存恢复失败等情况，必须抛出异常回滚事务。(先恢复数据库的，数据成功了，恢复缓存失败，抛出异常，数据库的也回滚了)

将订单置为取消状态
恢复库存
先恢复数据库，如果这一步恢复失败，直接就回滚了
再恢复redis，这一步恢复不成功，就直接抛异常

队列下单
获取库存缓存、本地没有就去分布式缓存拿(因为已经预热过了，分布式缓存里就应该有)
明确且唯一的编码以便于跟踪（用户id跟商品id 生成一个MD5编码）
    public String generatePlaceOrderTaskId(Long userId, Long itemId) {
            String toEncrypt = userId + "_" + itemId;
            return DigestUtils.md5DigestAsHex(toEncrypt.getBytes());
        }
提交下单任务到队列
    检查Redis中是否已经这个任务key，防重复下单，如果有，直接返回“请勿重复下单”
    获取可用许可
        先从本地缓存中查
        没有的话，刷心本地可用许可（加一个以商品id为key的分布式锁，防止并发更新）
            再去本地缓存中查，没有再去redis中查，redis中再没有，就去查商品的详情缓存
            从详情缓存中去获取库存
                用库存*1.5后，依次放入redis、本地缓存
    下单扣减许可
        在下单许可扣减时为了保证原子性，我们也采用LUA脚本的方案
            也就是说，当用户抢到了下单许可但是下单失败或取消订单时，系统会定时对数据进行纠正，
            腾出来空余的许可给后面需要的用户，确保所有库存均可对外销售
    投递下单任务
    投递成功之后，把这个taskKey放到redis中

    消费者接收下单任务消息
        校验下单规则
        获取商品库存
        生成唯一id
        库存扣减失败
        扣减成功之后，订单入库
        更新redis中任务的状态为1
        把这个任务taskId放入redis中，用于防重复下单
        如果下单中有异常，更新redis中任务的状态为-1

        轮询下单结果
        在接口方面，本次方案仅增加了任务结果轮询接口。需要注意的是，该接口用于轮询结果，且没有复杂计算和数据状态变更，在限流方面的阈值可以相对调高些


相较于前面的同步下单模式，异步队列模式将以异步的方式将并发处理的时间线拉长，从而提高整体的吞吐能力。
比如，同步模式下并发一次只能处理300个请求，但是队列模式下则可以处理30000+

对于库存扣减的设计，不同的业务目标、不同的用户体量，在设计时都会有不同的方案，并不存在一套方案放之四海而皆准的情况。
当我们的写并发量的300以下时，单纯的数据库方案即可胜任；
而当写并发量达到1000，数据库+缓存的方案仍然是有效的；
但是当并发量达到数千及更高是，分库分表的库存方案则是势在必行。