四）常用库存扣减方式
下单扣库存：优势在于简单，链路短，性能好，缺点在于容易被恶意下单。活动刚开始，可能即被恶意下单清空库存；
支付扣库存：优势在于可以控制恶意下单，最后得到库存的都是有效订单。当然，其缺点也较为明显，无法控制下单人数，用户需要在支付时再次确认库存；
下单预扣库存，超时取消：相较于前两种方式，这种方式较为折中且有效，对于正常下单的用户来说抢单即是得到，对于恶意下单的来说，占据的库存会超时自动释放。

到FlashSale，在库存扣减方面我们采用的是数据库+缓存的综合方案，充分利用两者的优点，并兼顾两者的平衡。
而在库存扣减方式上，我们采取的是下单扣库存，因为这种方式较快，比较适合秒杀场景。
此外，对于恶意下单的用户，我们也可以通过安全风控和策略来进行识别和屏蔽。

请求下单
    sentinel限流
        下单服务
            redis扣库存（lua脚本）
                数据库扣库存
                    订单落库

2. 取消订单
取消订单是下单的逆向操作。因此，下单时所发生的数据变更，在订单取消时需要恢复，包括订单数据、库存数据和库存缓存数据。需要关注的核心逻辑有：
    用户在执行取消动作时，必须先获得锁，防止抖动等造成重复取消；
    取消过程包括三个关键步骤：
        将订单置为取消状态；
        恢复秒杀品中的库存；
        恢复库存缓存中的库存。
    取消订单时如果出现库存恢复失败等情况，必须抛出异常回滚事务。

（一）库存预热与初始化
秒杀品在活动开始前，会将库存等数据提前写到缓存中，这个过程我们称之为库存的预热与初始化。在库存预热的过程中，涉及到两部分内容：
    预热调度；
    预热写缓存。

在活动开始前，由定时任务来完成秒杀品数据的预热。
预热调度在执行时，将会获取数据库中尚未预热的秒杀品，并遍历预热，预热完成后更新秒杀品在数据库中的状态。

预热写入缓存
NormalStockCacheService中库存初始化的源码如下所示，关键的逻辑要点包括：
    预热前必要的数据校验，如秒杀品是否存在等；
    获取库存初始化的锁，再次防止并发更新；
    未获得锁将终止本次预热，等待下次调度；
    预热时通过RedisTemplate执行LUA脚本；
    根据LUA脚本的返回值确定是否初始化成功；
    库存缓存的有效期设置要足够长。


LUA脚本
在通过缓存管理库存的过程中，原子性是一个重要的保证。为此，我们使用了LUA脚本，Redis会保证以原子性的方式运行LUA脚本。
NormalStockCacheService中，我们使用了三个LUA脚本：库存初始化脚本、库存扣减脚本和库存恢复脚本。
并且，这三个脚本在当前类加载时以static的方式完成初始化。

（二）库存扣减
首先需要明确的是，NormalStockCacheService中的库存扣减是预扣库存，而不是最终的库存扣减。换句话说，如果缓存中的库存扣减成功，则表示数据库中有库存，此时放行到数据库中进行新一轮的竞争。但是，如果缓存中的库存扣减失败，则表示库存已经不存在，此时不必再进入数据库竞争，可以直接拒绝本次请求。

库存扣减的相关源码如下所示，在这段源码中需要关注的核心逻辑主要包括：

当秒杀品的库存未预热时，将直接拒绝；
调用LUA脚本执行库存扣减（扣减的LUA脚本在下文有介绍）；
根据LUA脚本的返回码，判断扣减是否成功。

扣减库存LUA脚本
以下是库存扣减的LUA脚本，在脚本中只有返回1才表示库存扣减成功：

如果秒杀品库存不存在，返回-1；
如果当前剩余库存不足以扣减，返回-3；
如果扣减成功，返回1，否则返回-2；

MYSQL库存扣减
在库存层面完成扣减后，接下来就是数据库层面执行扣减
<update id="decreaseItemStock" parameterType="com.actionworks.flashsale.persistence.model.FlashItemDO">
    UPDATE flash_item
    SET modified_time = now(),
    available_stock = available_stock - #{quantity}
    where id = #{itemId} and available_stock <![CDATA[ >= ]]> #{quantity}
</update>

如果你对秒杀或高并发架构有所了解的话，可能会发现这句SQL并不完美。问题在于，它不是幂等的，在某些特殊情况下会发生重复扣减，这就违背本章节开篇的基本原则。那么，什么情况下会发生重复扣减？业务侧的代码不严谨地重试或底层的重试都会造成重复扣减。针对这个问题，有两个解决方案。

一是用设置库存取代扣库存，也就是将剩余库存在外部计算出来，并设置到数据库中，这样SQL就是幂等的：

<update id="decreaseItemStock" parameterType="com.actionworks.flashsale.persistence.model.FlashItemDO">
    UPDATE flash_item
    SET modified_time = now(),
    available_stock = #{newAvailableStock}
    stock_version = #{newStockVersion}
    where id = #{itemId} and stock_version = #{oldStockVersion}
</update>


二是通过CAS完成库存扣减，即在扣减库存的时候加上原始值。我们知道CAS是高效的无锁更新方式，在Java中有广泛应用，那么我们写个简单CAS：

<update id="decreaseItemStock" parameterType="com.actionworks.flashsale.persistence.model.FlashItemDO">
    UPDATE flash_item
    SET modified_time = now(),
    available_stock = available_stock - #{quantity}
    where id = #{itemId} and available_stock = #{oldAvailableStock}
</update>

（三）库存恢复
在用户取消订单或下单失败时，需要执行库存恢复，恢复过程包括缓存库存恢复和数据库库存恢复。库存恢复的源代码如下所示，需要关注的点包括：

恢复库存时，如果库存数据不存在，则拒绝恢复；
调用LUA脚本执行库存恢复；
根据LUA脚本的返回结果，判断恢复是否成功

MYSQL库存恢复
MySQL层面的库存恢复在逻辑上与前面的库存扣减类似。当然，它们的改进策略也是一致的。

（四）库存获取
    获取库存数据时，优先从本地缓存中读取（可能存在延迟或不一致，但可以接受）；
    本地缓存不在时，将通过秒杀品的库存KEY从分布式缓存中获取，并设置到本地中；
    在从分布式缓存中获取时，应当先获取对应的锁，否则返回稍后再试。

小结
对于库存扣减的设计，不同的业务目标、不同的用户体量，在设计时都会有不同的方案，并不存在一套方案放之四海而皆准的情况。
当我们的写并发量的300以下时，单纯的数据库方案即可胜任；
而当写并发量达到1000，数据库+缓存的方案仍然是有效的；但是当并发量达到数千及更高是，分库分表的库存方案则是势在必行。


库存获取章节，在多机器集群部署应用时候，如果先从本地缓存获取，那这个本地缓存的更新时机是怎样的？如果在扣减库存或恢复库存时不更新本地缓存，出现真实库存为0，但返回的库存还有的情况概率很高。
本地缓存采用时间和容量驱逐策略，这是多种因素平衡的结果。保证本地缓存的强一致性成本很高，而且也没用必要。参考12306的余票机制，页面数据短时间内滞后于服务端，在业务上是可以接受的。