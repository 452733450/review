mvcc
multi version concurrency control
https://blog.csdn.net/SnailMann/article/details/94724197

详细分析Mysql事务日志(redo log和undo log)
https://juejin.cn/post/6860252224930070536

索引的数据结构

一.单表优化：
字段：
20以内
避免使用null字段，很难查询，且占用额外索引空间
varchar的程度只分配真正需要的空间
尽量使用TIMESTAMP而非DATETIME
尽量使用TINYINT,SMALLLINT,MEDIUMINT,非负用UNSIGNED
适当添加冗余字段，避免过多的联表查询

索引：
适当建立索引，并及时清理无用的索引
索引建立的原则：
1.数据量大的表才适合建立索引
2.且查询操作较多，操作数据较小的
3.经常出现在where子句中的字段
4.可选择性高的字段，如性别就不适合建索引
5.索引应该建立在小字段上，大的文本字段甚至超长字段不适合建立索引
6.对于经常以AND形式出现在where子句的字段，单字段查询集合没有，可以考虑建立复合索引
7.对于已经存在的复合索引，它包含的字段如果经常单独出现在where子句中，那么可以考虑把复合索引分解为单字段索引，如果该复合索引包含的字段都有索引，就可以考虑删掉复合索引了

复合索引建立的原则：
把使用频度高的字段放在前面，系统会根据第一个字段来排序，把第一个字段排序后的相同的记录再 按照第二个字段进行排序,以此类推，所以只有第一个字段包含在查询条件中，该索引才有可能被使用，索引要把使用频度最高的放在前面，才能最大程度的使用索引
b+树是按照从左到右的顺序来建立搜索树的，当最左边的数据没有索引的时候，b+树就不知道下一步该查哪个节点
最左原则:查询从索引的最左前列开始并且不跳过索引中的列

索引失效的情况：
1.在where子句中使用!=,>,<
2.如果使用了or，那么就要给or条件中每个列加上索引，不然索引不会生效
3.用like模糊查询时，以%开头
4.字符串类型的数据要在条件中使用引号括起来。
5.使用复合索引时，第一个字段没有包含在查询条件中
6.如果mysql觉得使用全表扫描要比使用索引快，那么就不会使用索引
https://www.cnblogs.com/liehen2046/p/11052666.html


1.有or必全有索引;
2.复合索引未用左列字段;
3.like以%开头;
4.需要类型转换;比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5.where中索引列有运算;
6.where中索引列使用了函数;
7.如果mysql觉得全表扫描更快时（数据少）;

什么时没必要用
 1.唯一性差;
2.频繁更新的字段不用（更新索引消耗）;
3.where中不用的字段;
4.索引使用<>时，效果一般;
索引的最左原则
mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。

 sql语句优化：
1.开启慢查询日志（my.conf,slow_query_log,long_query_time）
2.sql语句尽可能简单，把大的sql语句拆成小的sql语句，一条大的sql语句有可能堵死整个库
3.不同select*,少用join，尽量避免使用like模糊查询, 避免不了也不要使用%开头
4.避免在where子句中使用!=,>,<，因为两种方式都会使得索引失效，从而导致扫描全表
5.使用exists或in查询两张表时，子查询表大的用exists，子查询表小的用in
6.不做列运算，任何针对列的运算都会导致扫描全表，如函数，数学表达式，因此，要把列运算放在等号的右边
7.相同类型的数据进行比较
8.连续数值用betwween
9.列表数据不要拿全表，用limit进行分页，一页的量也不要太大
10.不使用函数和触发器，在应用程序实现
系统调优参数
升级硬件
分库分表
读写分离
也是目前常用的优化，从库读主库写,aop实现主从表读写分离
缓存


1.不用select *
2.少用join
3.少用where!= < >
4.子查询表大用exist，子查询表小用in
5.同类型数据比较
6.不做列运算
7.连续数值用betwween
8.列表数据不要拿全表，用limit进行分页，一页的量也不要太大

