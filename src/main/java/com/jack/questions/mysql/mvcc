https://blog.csdn.net/SnailMann/article/details/94724197
当前读
像 select lock in share mode (共享锁), select for update; update; insert; delete (排他锁)这些操作都是一种当前读，为什么叫当前读？
就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁

快照读
像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；
之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，
但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

简而言之，MVCC 就是因为大佬们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，
而提出的解决方案，所以在数据库中，因为有了 MVCC，所以我们可以形成两个组合：
将要被修改的数据的最新记录中的 DB_TRX_ID取出来，即该条数据的最新记录
    MVCC + 悲观锁
    MVCC解决读写冲突，悲观锁解决写写冲突
    MVCC + 乐观锁
    MVCC 解决读写冲突，乐观锁解决写写冲突
读视图
正活跃的事务 ID 列表
如果符合可见性，那么这条数据的最新纪录就对当前事务可见
如果不符合，找到这条数据的最新记录的上一条数据，根据DB_ROLL_PTR(回滚指针)找

可见性判断
事务ID最小值 = 正活跃的事务 ID 列表最小值
事务ID最大值 = 正活跃的事务 ID 列表最大值 + 1

DB_TRX_ID < 最小值，说明 DB_TRX_ID不在活跃事务列表里，已经提交了，则当前事务能看到这条记录
DB_TRX_ID >= 最大值 则代表 DB_TRX_ID 所在的记录在 Read View 生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断，
    不可见就通过ROLL_PTR，找到上一条记录
DB_TRX_ID < 最大值 判断 DB_TRX_ID 是否在活跃事务之中
    trx_list.contains (DB_TRX_ID)，如果在，则代表我 Read View 生成时刻，你这个事务还在活跃，还没有 Commit，你修改的数据，我当前事务也是看不见的
    如果不在，则说明，你这个事务在 Read View 生成之前就已经 Commit 了,你修改的结果，我当前事务是能看见的