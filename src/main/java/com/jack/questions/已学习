多数据源
ZooKeeper watch机制
分布式锁
redis和ZooKeeper的区别
    zk分布式锁，就是某个节点尝试创建临时znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。
    　　释放锁就是删除这个znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。
    　　redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能
    　　zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小
    　　另外一点就是，如果是redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁；而zk的话，因为创建的是临时znode，只要客户端挂了，znode就没了，此时就自动释放锁
    四，对比
    数据库分布式锁实现
    缺点：
    1.db操作性能较差，并且有锁表的风险
    2.非阻塞操作失败后，需要轮询，占用cpu资源;
    3.长时间不commit或者长时间轮询，可能会占用较多连接资源
    Redis(缓存)分布式锁实现
    缺点：
    1.锁删除失败 过期时间不好控制
    2.非阻塞，操作失败后，需要轮询，占用cpu资源;
    ZK分布式锁实现
    缺点：性能不如redis实现，主要原因是写操作（获取锁释放锁）都需要在Leader上执行，然后同步到follower。
    总之：ZooKeeper有较好的性能和可靠性。
    从理解的难易程度角度（从低到高）数据库 > 缓存 > Zookeeper
    从实现的复杂性角度（从低到高）Zookeeper >= 缓存 > 数据库
    从性能角度（从高到低）缓存 > Zookeeper >= 数据库
    从可靠性角度（从高到低）Zookeeper > 缓存 > 数据库

    https://www.csdn.net/tags/MtTaMg2sNDMxNDA0LWJsb2cO0O0O.html
    两种锁，分别适用的场景为：
    （1）基于ZooKeeper的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景，没有羊群校园问题。
    （2）基于Redis的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景。
    总之，这里没有谁好谁坏的问题，而是谁更合适的问题。

限流算法
mvcc
数据库的锁