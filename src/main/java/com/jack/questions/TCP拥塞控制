拥塞控制
https://blog.csdn.net/weixin_43844995/article/details/125867738
https://www.cnblogs.com/dingpeng9055/p/16160746.html
流量控制和拥塞控制的区别
    流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。
    拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。

拥塞控制算法

RTT往返时间(Round Trip Time)
    用于建立TCP会话的往返行程时间(RTT)是发送请求包和接收响应包所需的时间量。
RTO Response TimeOut 应答超时
慢启动算法
    慢启动算法，表面意思就是，别急慢慢来。它表示TCP建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。
    由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，每收到一个ACK，就将拥塞窗口cwnd大小就加1（单位是MSS）。
    每轮次发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。

    TCP连接完成，初始化cwnd = 1，表明可以传一个MSS(最大报文段长度)单位大小的数据。
    每当收到一个ACK，cwnd就加一;
    每当过了一个RTT，cwnd就增加一倍; 呈指数让升
为了防止cwnd增长过大引起网络拥塞，还需设置一个慢启动阀值ssthresh（slow start threshold）状态变量。
当cwnd到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当cwnd >ssthresh时，进入了拥塞避免算法。

拥塞避免算法
一般来说，慢启动阀值ssthresh是65535字节，cwnd到达慢启动阀值后
    每收到一个ACK时，cwnd = cwnd + 1/cwnd
    当每过一个RTT时，cwnd = cwnd + 1
    显然这是一个线性上升的算法，避免过快导致网络拥塞问题。

拥塞发生
    当网络拥塞发生丢包时，会有两种情况：
        RTO超时重传
            当发送方未在规定时间内接收到 ACK 确认包时，就会超时重传。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。
            两次超时，就说明网络环境差，不宜频繁反复发送。
        快速重传
            首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。
            其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，
            从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。

    如果是发生了RTO(应答超时)超时重传，就会使用拥塞发生算法
        慢启动阀值sshthresh =  cwnd /2
        cwnd 重置为 1
        进入新的慢启动过程'
    这真的是辛辛苦苦几十年，一朝回到解放前。其实还有更好的处理方式，就是快速重传。
    发送方收到3个连续重复的ACK时，就会快速地重传，不必等待RTO超时再重传。
        慢启动阀值ssthresh 和 cwnd 变化如下：
            拥塞窗口大小 cwnd = cwnd/2
            慢启动阀值 ssthresh = cwnd
            进入快速恢复算法

    快速恢复
        快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有3个重复ACK收到，说明网络也没那么糟糕，
        所以没有必要像RTO超时那么强烈。

        正如前面所说，进入快速恢复之前，cwnd 和 sshthresh已被更新：
        然后，真正的快速算法如下：
            cwnd = sshthresh  + 3
            重传重复的那几个ACK（即丢失的那几个数据包）
            如果再收到重复的 ACK，那么 cwnd = cwnd +1
            如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。