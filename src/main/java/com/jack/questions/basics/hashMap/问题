https://mp.weixin.qq.com/s/eeFJSSMBdX7ZFqRNnSHayg

HashMap夺命连环21问
    https://mp.weixin.qq.com/s/2AUj3IkeUbEzHS1dKMuBbQ

HashMap 为什么链表到8之后转为红黑树，为什么6之后退回链表

你知道 hash 的实现吗？为什么要这样实现
是通过 hashCode() 的高 16 位异或低 16 位实现的

为什么要用异或运算符
保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。


HashMap进行扩容的时间点:
   1.put元素时,会触发resize方法在内部进行扩容,将把原来的数据rehash放进扩容后的桶中，
   2.数组的容量必须达到树化的容量的最小值默认64,才会进行树化，
      当当前数组的容量小于64则会触发扩容条件，从而调用resize方法然后又对已有的数据rehash迁移。
   3.添加完元素之后会判断当前容量是否达到了扩容阈值达到后还需要执行resize方法

总结：树化要求的最小容量是64，一旦发生树化，就会去检查当前容量，不足则进行扩容

为什么不用线性链表？
最差的情况下查询的时间复杂度会是O(N)


HashMap红黑树的阈值为什么是8？
之所以是8，是因为Java的源码贡献者在进行大量实验发现，hash碰撞发生8次的概率已经降低到了0.00000006，
几乎为不可能事件，如果真的碰撞发生了8次，那么这个时候说明由于元素本身和hash函数的原因，
此次操作的hash碰撞的可能性非常大了，后序可能还会继续发生hash碰撞。所以，这个时候，就应该将链表转换为红黑树了，
也就是为什么链表转红黑树的阈值是8。 最后，红黑树转链表的阈值为6，主要是因为，如果也将该阈值设置于8，
那么当hash碰撞在8时，会反生链表和红黑树的不停相互激荡转换，白白浪费资源。
