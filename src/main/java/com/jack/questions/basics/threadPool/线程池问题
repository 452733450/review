中通
线程池支持参数动态修改吗

zk
线程池创建里面的核心线程什么时候创建，队列什么时候创建

众安
线程池的参数？核心线程5，最大8，队列5，讲一下从开始创建线程池到最后结束的整个过程

极兔
线程池创建里面的核心线程什么时候创建，队列什么时候创建，
    判断当前运行的worker数量是否超过corePoolSize,如果不超过corePoolSize。就创建一个worker直接执行该任务。—— 线程池最开始是没有worker在运行的
    如果正在运行的worker数量超过或者等于corePoolSize,那么就将该任务加入到workQueue队列中去。
    如果workQueue队列满了,也就是offer方法返回false的话，就检查当前运行的worker数量是否小于maximumPoolSize,如果小于就创建一个worker直接执行该任务。
    如果当前运行的worker数量是否大于等于maximumPoolSize，那么就执行RejectedExecutionHandler来拒绝这个任务的提交。

理想one
线程池几个参数聊聊，
为什么要用线程池


为什么会有线程池？
简单手写一个线程池？
为什么要把任务先放在任务队列里面，而不是把线程先拉满到最大线程数？
线程池如何动态修改核心线程数和最大线程数？
如果你是 JDK 设计者，如何设计？
如果要让你设计一个线程池，你要怎么设计？
你是如何理解核心线程的？
你是怎么理解 KeepAliveTime 的？
    这就是上面提到的，线程池其实想要的只是核心线程数个线程，但是又预留了一些数量来预防突发状况，
    当突发状况过去之后，线程池希望只维持核心线程数的线程，所以就弄了个 KeepAliveTime，
    当线程数大于核心数之后，如果线程空闲了一段时间（KeepAliveTime），就回收线程，直到数量与核心数持平。
那 workQueue 有什么用？
    缓存任务供线程获取，这里要注意限制工作队列的大小。队列长了，堆积的任务就多，堆积的任务多，后面任务等待的时长就长。
    想想你点击一个按钮是一直转圈等半天没反应舒服，还是直接报错舒服，所以有时心是好的，想尽量完成提交的任务，
    但是用户体验不如直接拒绝。更有可能由于允许囤积的任务过多，导致资源耗尽而系统崩溃。
你是如何理解拒绝策略的？
    线程数总有拉满的一天，工作队列也是一样，如果两者都满了，此时的提交任务就需要拒绝，默认实现是 AbortPolicy 直接抛出异常。
    剩下的拒绝策略有直接丢弃任务一声不吭的、让提交任务的线程自己运行的、淘汰老的未执行的任务而空出位置的，具体用哪个策略，根据场景选择。
    当然也可以自定义拒绝策略，实现 RejectedExecutionHandler 这个接口即可。
    所以线程池尽可能只维护核心数量的线程，提供任务队列暂存任务，并提供拒绝策略来应对过载的任务。
    这里还有个细节，如果线程数已经达到核心线程数，那么新增加的任务只会往任务队列里面塞，不会直接给予某个线程，
    如果任务队列也满了，新增最大线程数的线程时，任务是可以直接给予新建的线程执行的，而不是入队。
你说你看过源码，那你肯定知道线程池里的 ctl 是干嘛的咯？
你知道线程池有几种状态吗？
    RUNNING：能接受新任务，并处理阻塞队列中的任务
    SHUTDOWN：不接受新任务，但是可以处理阻塞队列中的任务
    STOP：不接受新任务，并且不处理阻塞队列中的任务，并且还打断正在运行任务的线程，就是直接撂担子不干了！
    TIDYING：所有任务都终止，并且工作线程也为0，处于关闭之前的状态
    TERMINATED：已关闭。
    shutdownNow会导致，比如你只有两个线程，但是放入了3个工作任务；其中一个任务在队列还没处理的时候；
    调用了该方法会走拒绝策略（报错）；shutdown会继续执行队列任务
你知道线程池的状态是如何变迁的吗？
如何修改原生线程池，使得可以先拉满线程数再入任务队列排队？
Tomcat 中的定制化线程池实现 如果线程池中的线程在执行任务的时候，抛异常了，会怎么样？
原生线程池的核心线程一定伴随着任务慢慢创建的吗？
线程池的核心线程在空闲的时候一定不会被回收吗？