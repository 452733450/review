aqs
    同步队列
    双向链表
    每个线程包裹成一个node
    aqs属性：head，tail，state(当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁)，exclusiveOwnerThread()
    Node属性：pre,next,waitStatus(-1代表当前节点的下一个节点等待唤醒，1代表取消排队),Thread(包裹的线程)
    state=0，去cas抢锁
    或者线程是当前持有锁的线程又来获取锁，就是可重入锁，state+1
    抢不到锁，就自旋不断尝试入队，入队就是把自己设置成尾节点，原来的尾节点设置成自己的前节点
    入队之后，要把线程挂起，这时候要去判断一下，node是不是head，如果是head，尝试去获取锁，获取到了，就不用挂起了，
        这时，head就是持有锁的节点
    如果不是head，则走判断是不是要挂起的方法，前驱节点和当前节点，判断前驱节点的waitStatus是不是=-1，如果是>0的，要一直往前找，
    找到一个不是>0的节点，然后cas把这个节点的waitStatus设置为-1，设置不成功，就再走for循环，一直到设置成功

    解锁
        拿当前线程的state-1，看是不是=0，不等于0还不能完全释放，因为是可重入锁
        等于0，去释放锁，把head的waitStatus改为0
        唤醒后继节点，找到第一个waitStatus<0的节点，然后唤醒线程，LockSupport.unpark(s.thread);

    final boolean acquireQueued(final Node node, int arg) {
            boolean failed = true;
            try {
                boolean interrupted = false;
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {
                        // 当前节点的前驱节点为头节点，也就是获取锁的节点
                        setHead(node);
                        p.next = null; // help GC
                        failed = false;
                        return interrupted;
                    }
                    if (shouldParkAfterFailedAcquire(p, node) &&
                        parkAndCheckInterrupt())
                        interrupted = true;
                }
            } finally {
                if (failed)
                    cancelAcquire(node);
            }
        }

    // 解锁
    public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null && h.waitStatus != 0)
                    // 唤醒头节点的下一个节点，并把头节点的waitStatus设为0
                    unparkSuccessor(h);
                return true;
            }
            return false;
        }

可重入锁
    可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。
    synchronized 和 ReentrantLock 都是可重入锁。
    他内部维护了一个Sync类 这个Sync又有一个state的变量 这就是可重入的关键
公平锁和非公平锁
    lock()方法,非公平锁一进来就会进行一次cas获取锁，成功就返回了
    tryAcquire()state=0 的时候，公平锁会去看一下，队列里有没有线程在排队，如果有，就不去抢锁
    总结：公平锁和非公平锁只有两处不同：
    非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。
    非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。
sync和reentrant lock区别
    1.Synchronized是java的关键字
    2.ReentrantLock是jdk1.5以后引进来的方法,是Lock类的实现类默认的是非公平锁
    3.Synchronized不需要手动的获取锁和释放锁ReentrantLock是需要手动的获取锁（lock()）和释放锁(unlock())
    4.reentrantlock支持公平锁和非公平锁 而synchronized 仅支持非公平锁。
    5. Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等。
    6.锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized
redis限流
线程的生命周期