aqs
    同步队列
    双向链表
    每个线程包裹成一个node
    aqs属性：head，tail，state(当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁)，exclusiveOwnerThread()
    Node属性：pre,next,waitStatus(-1代表当前节点的下一个节点等待唤醒，1代表取消排队),Thread(包裹的线程)
    state=0，去cas抢锁
    或者线程是当前持有锁的线程又来获取锁，就是可重入锁，state+1
    抢不到锁，就自旋不断尝试入队，入队就是把自己设置成尾节点，原来的尾节点设置成自己的前节点
    入队之后，要把线程挂起，要一直往前找，找到waitStatus不是大于0的，然后把这个waitStatus设置为-1，然后把线程挂起，
        这时候要去判断一下，node是不是head，如果是head，尝试去获取锁，获取到了，就不用挂起了，
        这时，head就是持有锁的节点
    如果不是head，则走判断是不是要挂起的方法，前驱节点和当前节点，判断前驱节点的waitStatus是不是=-1，如果是>0的，要一直往前找，
    找到一个不是>0的节点，然后cas把这个节点的waitStatus设置为-1，设置不成功，就再走for循环，一直到设置成功

    解锁
        拿当前线程的state-1，看是不是=0，不等于0还不能完全释放，因为是可重入锁
        等于0，去释放锁，把head的waitStatus改为0
        唤醒后继节点，从队尾往前找，找到waitStatus<=0的所有节点中排在最前面的，找到第一个waitStatus<0的节点，然后唤醒线程，LockSupport.unpark(s.thread);

    final boolean acquireQueued(final Node node, int arg) {
            boolean failed = true;
            try {
                boolean interrupted = false;
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {
                        // 当前节点的前驱节点为头节点，也就是获取锁的节点
                        setHead(node);
                        p.next = null; // help GC
                        failed = false;
                        return interrupted;
                    }
                    if (shouldParkAfterFailedAcquire(p, node) &&
                        parkAndCheckInterrupt())
                        interrupted = true;
                }
            } finally {
                if (failed)
                    cancelAcquire(node);
            }
        }

    // 解锁
    public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null && h.waitStatus != 0)
                    // 唤醒头节点的下一个节点，并把头节点的waitStatus设为0
                    unparkSuccessor(h);
                return true;
            }
            return false;
        }

可重入锁
    可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。
    synchronized 和 ReentrantLock 都是可重入锁。
    他内部维护了一个Sync类 这个Sync又有一个state的变量 这就是可重入的关键
公平锁和非公平锁
    lock()方法,非公平锁一进来就会进行一次cas获取锁，成功就返回了
    tryAcquire()state=0 的时候，公平锁会去看一下，队列里有没有线程在排队，如果有，就不去抢锁
    总结：公平锁和非公平锁只有两处不同：
    非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。
    非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。
sync和reentrant lock区别
    1.Synchronized是java的关键字
    2.ReentrantLock是jdk1.5以后引进来的方法,是Lock类的实现类默认的是非公平锁
    3.Synchronized不需要手动的获取锁和释放锁ReentrantLock是需要手动的获取锁（lock()）和释放锁(unlock())
    4.reentrantlock支持公平锁和非公平锁 而synchronized 仅支持非公平锁。
    5. Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等。
    6.锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized
redis限流

2022-06-30
线程的生命周期
    一、线程的生命周期总结下来分为以下五种：
    （1）新建：当一个Thread类或其子类的对象被声明并创建时。新生的线程对象属于新建状态。
    （2）就绪：处于新建状态的线程执行start()方法后，进入线程队列等待CPU时间片，该状态具备了运行的状态，只是没有分配到CPU资源。
    （3）运行：当就绪的线程分配到CPU资源便进入运行状态，run()方法定义了线程的操作。
    （4）阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时终止自己的的执行，进入阻塞状态。
    （5）死亡：当线程执行完自己的操作或提前被强制性的终止或出现异常导致结束，会进入死亡状态。
创建线程的几种方式
extends Thread
实现Runnable Callable接口
notify()和notifyAll()区别
    notify()和notifyAll()都是用来用来唤醒调用wait(）方法进入等待锁资源队列的线程，区别在于：
    notify()
    唤醒正在等待此对象监视器的单个线程。 如果有多个线程在等待，则选择其中一个随机唤醒（由调度器决定），唤醒的线程享有公平竞争资源的权利
    notifyAll()
    唤醒正在等待此对象监视器的所有线程，唤醒的所有线程公平竞争资源

    1.wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)
    2.notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。
    3.wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
join()
wait() 等待同步锁
suspend()
    suspend() 和 resume() ：这两个方法是配套使用的，suspend() 是让线程进入阻塞状态，它的解药就是resume()，没有resume()它自己是不会恢复的，由于这种比较容易出现死锁现象，所以jdk1.5之后就已经被废除了，这对就是相爱相杀的一对。
yield()
    start() 启动线程，并调用run()
    run()：线程要执行的代码写在方法里
    currentThread()静态代码，返回执行当前代码的线程
    getName() 获得线程的名字
    setName() 设置线程的名字
    yield() 释放当前cpu的执行权
    join() 在线程a中调用线程b的join(),此时线程a进入阻塞状态，直到线程b执行完，线程a才继续执行
    stop() 强制结束线程(不推荐使用)
    sleep(1000) 线程阻塞1s
    isAlive() 判断当前线程是否存活
    suspend() 和 resume() ：这两个方法是配套使用的，suspend() 是让线程进入阻塞状态，它的解药就是resume()，没有resume()它自己是不会恢复的，由于这种比较容易出现死锁现象，所以jdk1.5之后就已经被废除了，这对就是相爱相杀的一对。

线程池
线程和进程的区别
    进程：
        指在系统中正在运行的一个应用程序；程序一旦运行就是进程
        或者更专业化来说：进程是指程序执行时的一个实例
        从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。
    线程：
        线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位
        系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。
    进程——资源分配的最小单位，线程——程序执行的最小单位。
进程和线程的关系：
    1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。
    2、资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。
    3、处理机分给线程，即真正在处理机上运行的是线程。
    4、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

线程与进程的区别可以归纳为以下4点：
    1）地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
    2）通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
    3）调度和切换：线程上下文切换比进程上下文切换要快得多。
    4）在多线程OS中，进程不是一个可执行的实体。


分布式事务
零拷贝
分库分表id，怎么分，数据分片怎么分
    时间范围 时候一些历史文件 ,统计啥的
    hash 时候 用户 与 用户关联资源的
类加载
    加载、连接、初始化

什么是Class文件
Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。
    它是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙，
    这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间（方便于网络的传输）。
Java源文件在被Java编译器编译之后， 每个类（或者接口）都单独占据一个class文件，
    并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。

1.常量池是什么
常量池是字节码文件的一部分。
    JVM为每一个已经被加载的类型（类或者接口）都维护一个常量池，其中的数据项像数组项一样，通过索引访问。
    常量池中存储的数据类型：数量值、字符串值、类引用、方法引用、字段（属性）引用。
java字节码文件中，除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含常量池表（Constant Pool Table），
    在常量池表中包含了各种字面量和对类型、域（Field）、方法的符号的引用。
也就是说常量池中的数据以类似表的形式在常量池表中呈现，我们可以通过将编译后的字节码文件进行反编译来查看具体的内容，
    这里我们通过字节码查看工具jclasslib来查看。
2.什么是运行时常量池
运行时常量池是方法区的一部分。字节码文件中的常量池经过类加载子系统被加载到方法区后形成的结构就称为运行时常量池。

new 一个对象
synchronized

String 为什么是final
    因为String类要保证他的实例不可变，不可变和被final修饰其实是两件事。
    String为了保证他的实例不可变做了三件事：
        内部成员变量char[]被final修饰，char[] 引用地址不可变。
        private修饰所有对外提供的方法，都不会去尝试修改char[]内部的元素。这就是封装的好处。
        String类被final修饰，类不可以被继承。规避了有坏人想尝试通过继承重写来破坏String内部的数据。
为什么String类实例要设定为不可变？
    字符串缓冲池，使用享元模式，减少String对象的产生，而享元模式的弊端就是对象的内部状态不可变。
    使用安全，String是我们程序中最最常用的对象，不可变规避了直接在堆中直接改变对象内容，除非我们主动修改引用地址，否则我们将String传递进任何方法中，他都不会改变。防止一不小心就在其他函数内被更改了。
    线程安全，并发使用String时，不需要再去考虑他的线程安全问题。
    性能，由于String一出生或一初始化就不可变，所以一个String的hashcode是固定的不变的，可以只计算一次，并且String是最适合作为hash表结构中Key的类。
    设定为不可变之后，String就更贴近一个基本类型了，这可能也是JDK开发者的期望。

    从内存角度来看
    字符串常量池的要求：创建字符串时，如果该字符串已经存在于池中，则将返回现有字符串的引用，而不是创建新对象。字符串池的实现可以在运行时节约很多heap空间，多个String变量引用指向同一个内地地址。如果字符串是可变的，用一个引用更改字符串将导致其他引用的值错误。这是很危险的。
    缓存Hashcode
    字符串的Hashcode在java中经常配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。
    不可变的特性保证了hashcode永远是相同的。不用每次使用hashcode就需要计算hashcode。
    这样更有效率。因为当向集合中插入对象时，是通过hashcode判别在集合中是否已经存在该对象了（不是通过equals方法逐个比较，效率低）。
    安全性
    String被广泛用作许多java类的参数，例如网络连接、打开文件等。如果对string的某一处改变一不小心就影响了该变量所有引用的表现，则连接或文件将被更改，这可能导致严重的安全威胁。
    不可变对象不能被写，所以不可变对象自然是线程安全的，因为不可变对象不能更改，它们可以在多个线程之间自由共享。



equals与==区别？
    == 的作用：
    　　基本类型：比较的就是值是否相同
    　　引用类型：比较的就是地址值是否相同
    equals 的作用:
    　　引用类型：默认情况下，比较的是地址值。
    注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同
cas是怎么保证原子性的
    ①CAS并发原语提现在Java语言中就是sun.misc包下的UnSaffe类中的各个方法.调用UnSafe类中的CAS方法,JVM会帮我实现 CAS汇编指令.
    这是一种完全依赖于硬件 功能,通过它实现了原子操作,再次强调,由于CAS是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,
    并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题
spring bean生命周期
    四个阶段
    实例化 Instantiation
    属性赋值 Populate
    初始化 Initialization
    销毁 Destruction
单例为什么要双重判空
    https://juejin.cn/post/6844904170785374222
    从运行结果可以看出，如果不进行第二次判空的话，那么在竟锁池（(锁池）中如果还有活跃的线程在等待获取的锁的话，在锁释放后就会再次竞争获取锁，
    获取的锁的线程进入"就绪状态"，当CPU分配其"时间片"后进行线程的调度，从而线程进入"运行中状态"，并会去执行同步的代码块，如果在没加如二次判空的话，
    就会导致系统中存在多个实例，而在进行判空后，即使你获取到了锁，但在执行同步代码块时也会直接跳过。

    就是多个线程在竞争锁，拿到锁的线程执行完之后，创建了对象，然后竞锁池(waitSet里)线程下一个线程就获取到锁，如果没有判空，就又会去创建对象

    1.为何在synchronization外面的判断？

    为了提高性能！如果拿掉这次的判断那么在行的时候就会直接的运行synchronization，所以这会使每个getInstance()都会得到一个静态内部锁，这样的话锁的获得以及释放的开销（包括上下文切换，内存同步等）都不可避免，降低了效率。
    所以在synchronization前面再加一次判断是否为空，则会大大降低synchronization块的执行次数。
多线程交替打印ABC的多种实现方法
一、Synchronized同步法
    使用同步块和wait、notify的方法控制三个线程的执行次序
二、Lock锁方法
三、ReentrantLock结合Condition
逃逸分析
三色标记

分布式一致性策略、算法
ZAB 协议，ZK 选举过程，ZXID 的结构是怎么样的？ZXID 有什么用？
Paxos 算法了解吗？介绍 RAFT 和 ZAB，以及它们之间的区别？会有脑裂问题吗？为什么？
groovy脚本

select count(1) count(*)区别
HashMap 1.7 1.8 resize()扩容区别
尾插法为什么会形成链表
    https://blog.csdn.net/no_away/article/details/122474508
AutoInteger怎么保证原子性
lock前缀指令
zgc
三色标记
逃逸分析
对象(再)分配(什么情况下)
tcp和udp的区别