aqs
    同步队列
    双向链表
    每个线程包裹成一个node
    aqs属性：head，tail，state(当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁)，exclusiveOwnerThread()
    Node属性：pre,next,waitStatus(-1代表当前节点的下一个节点等待唤醒，1代表取消排队),Thread(包裹的线程)
    state=0，去cas抢锁
    或者线程是当前持有锁的线程又来获取锁，就是可重入锁，state+1
    抢不到锁，就自旋不断尝试入队，入队就是把自己设置成尾节点，原来的尾节点设置成自己的前节点
    入队之后，要把线程挂起，要一直往前找，找到waitStatus不是大于0的，然后把这个waitStatus设置为-1，然后把线程挂起，
        这时候要去判断一下，node是不是head，如果是head，尝试去获取锁，获取到了，就不用挂起了，
        这时，head就是持有锁的节点
    如果不是head，则走判断是不是要挂起的方法，前驱节点和当前节点，判断前驱节点的waitStatus是不是=-1，如果是>0的，要一直往前找，
    找到一个不是>0的节点，然后cas把这个节点的waitStatus设置为-1，设置不成功，就再走for循环，一直到设置成功

    解锁
        拿当前线程的state-1，看是不是=0，不等于0还不能完全释放，因为是可重入锁
        等于0，去释放锁，把head的waitStatus改为0
        唤醒后继节点，从队尾往前找，找到waitStatus<=0的所有节点中排在最前面的，找到第一个waitStatus<0的节点，然后唤醒线程，LockSupport.unpark(s.thread);

    final boolean acquireQueued(final Node node, int arg) {
            boolean failed = true;
            try {
                boolean interrupted = false;
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {
                        // 当前节点的前驱节点为头节点，也就是获取锁的节点
                        setHead(node);
                        p.next = null; // help GC
                        failed = false;
                        return interrupted;
                    }
                    if (shouldParkAfterFailedAcquire(p, node) &&
                        parkAndCheckInterrupt())
                        interrupted = true;
                }
            } finally {
                if (failed)
                    cancelAcquire(node);
            }
        }

    // 解锁
    public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null && h.waitStatus != 0)
                    // 唤醒头节点的下一个节点，并把头节点的waitStatus设为0
                    unparkSuccessor(h);
                return true;
            }
            return false;
        }

可重入锁
    可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。
    synchronized 和 ReentrantLock 都是可重入锁。
    他内部维护了一个Sync类 这个Sync又有一个state的变量 这就是可重入的关键
公平锁和非公平锁
    lock()方法,非公平锁一进来就会进行一次cas获取锁，成功就返回了
    tryAcquire()state=0 的时候，公平锁会去看一下，队列里有没有线程在排队，如果有，就不去抢锁
    总结：公平锁和非公平锁只有两处不同：
    非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。
    非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。
sync和reentrant lock区别
    1.Synchronized是java的关键字
    2.ReentrantLock是jdk1.5以后引进来的方法,是Lock类的实现类默认的是非公平锁
    3.Synchronized不需要手动的获取锁和释放锁ReentrantLock是需要手动的获取锁（lock()）和释放锁(unlock())
    4.reentrantlock支持公平锁和非公平锁 而synchronized 仅支持非公平锁。
    5. Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等。
    6.锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized
redis限流

2022-06-30
线程的生命周期
    一、线程的生命周期总结下来分为以下五种：
    （1）新建：当一个Thread类或其子类的对象被声明并创建时。新生的线程对象属于新建状态。
    （2）就绪：处于新建状态的线程执行start()方法后，进入线程队列等待CPU时间片，该状态具备了运行的状态，只是没有分配到CPU资源。
    （3）运行：当就绪的线程分配到CPU资源便进入运行状态，run()方法定义了线程的操作。
    （4）阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时终止自己的的执行，进入阻塞状态。
    （5）死亡：当线程执行完自己的操作或提前被强制性的终止或出现异常导致结束，会进入死亡状态。
创建线程的几种方式
extends Thread
实现Runnable Callable接口
notify()和notifyAll()区别
    notify()和notifyAll()都是用来用来唤醒调用wait(）方法进入等待锁资源队列的线程，区别在于：
    notify()
    唤醒正在等待此对象监视器的单个线程。 如果有多个线程在等待，则选择其中一个随机唤醒（由调度器决定），唤醒的线程享有公平竞争资源的权利
    notifyAll()
    唤醒正在等待此对象监视器的所有线程，唤醒的所有线程公平竞争资源

    1.wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)
    2.notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。
    3.wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
join()
wait() 等待同步锁
suspend()
    suspend() 和 resume() ：这两个方法是配套使用的，suspend() 是让线程进入阻塞状态，它的解药就是resume()，没有resume()它自己是不会恢复的，由于这种比较容易出现死锁现象，所以jdk1.5之后就已经被废除了，这对就是相爱相杀的一对。
yield()
    start() 启动线程，并调用run()
    run()：线程要执行的代码写在方法里
    currentThread()静态代码，返回执行当前代码的线程
    getName() 获得线程的名字
    setName() 设置线程的名字
    yield() 释放当前cpu的执行权
    join() 在线程a中调用线程b的join(),此时线程a进入阻塞状态，直到线程b执行完，线程a才继续执行
    stop() 强制结束线程(不推荐使用)
    sleep(1000) 线程阻塞1s
    isAlive() 判断当前线程是否存活
    suspend() 和 resume() ：这两个方法是配套使用的，suspend() 是让线程进入阻塞状态，它的解药就是resume()，没有resume()它自己是不会恢复的，由于这种比较容易出现死锁现象，所以jdk1.5之后就已经被废除了，这对就是相爱相杀的一对。

线程池
线程和进程的区别
    进程：
        指在系统中正在运行的一个应用程序；程序一旦运行就是进程
        或者更专业化来说：进程是指程序执行时的一个实例
        从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。
    线程：
        线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位
        系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。
    进程——资源分配的最小单位，线程——程序执行的最小单位。
进程和线程的关系：
    1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。
    2、资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。
    3、处理机分给线程，即真正在处理机上运行的是线程。
    4、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

线程与进程的区别可以归纳为以下4点：
    1）地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
    2）通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
    3）调度和切换：线程上下文切换比进程上下文切换要快得多。
    4）在多线程OS中，进程不是一个可执行的实体。


分布式事务

分库分表id，怎么分，数据分片怎么分
    时间范围 时候一些历史文件 ,统计啥的
    hash 时候 用户 与 用户关联资源的
类加载
    加载、连接、初始化

什么是Class文件
Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。
    它是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙，
    这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间（方便于网络的传输）。
Java源文件在被Java编译器编译之后， 每个类（或者接口）都单独占据一个class文件，
    并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。

1.常量池是什么
常量池是字节码文件的一部分。
    JVM为每一个已经被加载的类型（类或者接口）都维护一个常量池，其中的数据项像数组项一样，通过索引访问。
    常量池中存储的数据类型：数量值、字符串值、类引用、方法引用、字段（属性）引用。
java字节码文件中，除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含常量池表（Constant Pool Table），
    在常量池表中包含了各种字面量和对类型、域（Field）、方法的符号的引用。
也就是说常量池中的数据以类似表的形式在常量池表中呈现，我们可以通过将编译后的字节码文件进行反编译来查看具体的内容，
    这里我们通过字节码查看工具jclasslib来查看。
2.什么是运行时常量池
运行时常量池是方法区的一部分。字节码文件中的常量池经过类加载子系统被加载到方法区后形成的结构就称为运行时常量池。

new 一个对象
synchronized

String 为什么是final
    因为String类要保证他的实例不可变，不可变和被final修饰其实是两件事。
    String为了保证他的实例不可变做了三件事：
        内部成员变量char[]被final修饰，char[] 引用地址不可变。
        private修饰所有对外提供的方法，都不会去尝试修改char[]内部的元素。这就是封装的好处。
        String类被final修饰，类不可以被继承。规避了有坏人想尝试通过继承重写来破坏String内部的数据。
为什么String类实例要设定为不可变？
    字符串缓冲池，使用享元模式，减少String对象的产生，而享元模式的弊端就是对象的内部状态不可变。
    使用安全，String是我们程序中最最常用的对象，不可变规避了直接在堆中直接改变对象内容，除非我们主动修改引用地址，否则我们将String传递进任何方法中，他都不会改变。防止一不小心就在其他函数内被更改了。
    线程安全，并发使用String时，不需要再去考虑他的线程安全问题。
    性能，由于String一出生或一初始化就不可变，所以一个String的hashcode是固定的不变的，可以只计算一次，并且String是最适合作为hash表结构中Key的类。
    设定为不可变之后，String就更贴近一个基本类型了，这可能也是JDK开发者的期望。

    从内存角度来看
    字符串常量池的要求：创建字符串时，如果该字符串已经存在于池中，则将返回现有字符串的引用，而不是创建新对象。字符串池的实现可以在运行时节约很多heap空间，多个String变量引用指向同一个内地地址。如果字符串是可变的，用一个引用更改字符串将导致其他引用的值错误。这是很危险的。
    缓存Hashcode
    字符串的Hashcode在java中经常配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。
    不可变的特性保证了hashcode永远是相同的。不用每次使用hashcode就需要计算hashcode。
    这样更有效率。因为当向集合中插入对象时，是通过hashcode判别在集合中是否已经存在该对象了（不是通过equals方法逐个比较，效率低）。
    安全性
    String被广泛用作许多java类的参数，例如网络连接、打开文件等。如果对string的某一处改变一不小心就影响了该变量所有引用的表现，则连接或文件将被更改，这可能导致严重的安全威胁。
    不可变对象不能被写，所以不可变对象自然是线程安全的，因为不可变对象不能更改，它们可以在多个线程之间自由共享。



equals与==区别？
    == 的作用：
    　　基本类型：比较的就是值是否相同
    　　引用类型：比较的就是地址值是否相同
    equals 的作用:
    　　引用类型：默认情况下，比较的是地址值。
    注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同
cas是怎么保证原子性的
    ①CAS并发原语提现在Java语言中就是sun.misc包下的UnSaffe类中的各个方法.调用UnSafe类中的CAS方法,JVM会帮我实现 CAS汇编指令.
    这是一种完全依赖于硬件 功能,通过它实现了原子操作,再次强调,由于CAS是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,
    并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题
spring bean生命周期
    四个阶段
    实例化 Instantiation
    属性赋值 Populate
    初始化 Initialization
    销毁 Destruction
单例为什么要双重判空
    https://juejin.cn/post/6844904170785374222
    从运行结果可以看出，如果不进行第二次判空的话，那么在竟锁池（(锁池）中如果还有活跃的线程在等待获取的锁的话，在锁释放后就会再次竞争获取锁，
    获取的锁的线程进入"就绪状态"，当CPU分配其"时间片"后进行线程的调度，从而线程进入"运行中状态"，并会去执行同步的代码块，如果在没加如二次判空的话，
    就会导致系统中存在多个实例，而在进行判空后，即使你获取到了锁，但在执行同步代码块时也会直接跳过。

    就是多个线程在竞争锁，拿到锁的线程执行完之后，创建了对象，然后竞锁池(waitSet里)线程下一个线程就获取到锁，如果没有判空，就又会去创建对象

    1.为何在synchronization外面的判断？

    为了提高性能！如果拿掉这次的判断那么在行的时候就会直接的运行synchronization，所以这会使每个getInstance()都会得到一个静态内部锁，这样的话锁的获得以及释放的开销（包括上下文切换，内存同步等）都不可避免，降低了效率。
    所以在synchronization前面再加一次判断是否为空，则会大大降低synchronization块的执行次数。
多线程交替打印ABC的多种实现方法
一、Synchronized同步法
    使用同步块和wait、notify的方法控制三个线程的执行次序
二、Lock锁方法
三、ReentrantLock结合Condition
逃逸分析
    当一个对象在方法中被定义后，对象只能在方法内部使用，则认为没有发生逃逸
    当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中
三色标记
    白色：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。
    黑色：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了（本对象的孩子节点也都被访问过）。
    灰色：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态（本对象的孩子节点还没有访问）。
标记过程：

初始时，所有对象都在 【白色集合】中；
将GC Roots 直接引用到的对象 挪到 【灰色集合】中；
从灰色集合中获取对象：
3.1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；
3.2. 将本对象 挪到 【黑色集合】里面。
重复步骤3，直至【灰色集合】为空时结束。
结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收


分布式一致性策略、算法
ZAB 协议，ZK 选举过程，ZXID 的结构是怎么样的？ZXID 有什么用？
Paxos 算法了解吗？介绍 RAFT 和 ZAB，以及它们之间的区别？会有脑裂问题吗？为什么？
groovy脚本

select count(1) count(*)区别
HashMap 1.7 1.8 resize()扩容区别
尾插法为什么会形成链表
    https://blog.csdn.net/no_away/article/details/122474508
AutoInteger怎么保证原子性
lock前缀指令
zgc
三色标记
逃逸分析
对象(再)分配(什么情况下)
tcp和udp的区别
    TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）
TCP协议指的是传输控制协议，是一个面向连接的传输协议，他是一个能提供高可靠性的通信协议，
    所谓高可靠性指的是数据无丢失、数据无误、数据无失序、数据无重到达。就像图上所示，TCP能把“孩子”安全地送到接收者手上。
TCP适用场景：
    适用于对传输质量要求较高，以及传输大量数据的通信场景（如文件传输）。
    在需要传输可靠数据的场合通常会选择使用TCP通信协议。
    比如QQ/微信/支付宝等通信软件的账户登录和支付相关功能是通常采用可靠的TCP通信协议来实现。

UDP协议指的是用户数据报协议，是一种不可靠无连接、实时性高的协议，在数据发送前，
    不需要提前建立连接，所以可以更高效地传输数据。
    但可靠性无法保证，如第一张图所示，UDP只管把“孩子”送出去，接受者有没有收到也不管。

视频、语音为什么用tcp
丢了几个包可能就是画质没那么清晰、没那么顺畅，但实时性高其实并不太影响我们日常使用。
如果用tcp进行聊天的话，因为它效率非常低。很有可能你女朋友和你说她吃完饭准备洗澡了，电话这头的你还是以为女朋友在吃饭（tcp传输效率低，导致延迟很高）。

eureka, nacos, zookeeper区别
    3.1 Zookeeper保证CP
    当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。
    也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，
    剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。
    在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。

    3.2 Eureka保证AP
    Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。
    而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，
    只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，
    那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： 
        1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 
        2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 
        3. 当网络稳定时，当前实例新的注册信息会被同步到其它节点中
        因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。

    Consul：
    Consul 遵循CAP原理中的CP原则，保证了强一致性和分区容错性，且使用的是Raft算法，比zookeeper使用的Paxos算法更加简单。虽然保证了强一致性，但是可用性就相应下降了，例如服务注册的时间会稍长一些，因为 Consul 的 raft 协议要求必须过半数的节点都写入成功才认为注册成功 ；在leader挂掉了之后，重新选举出leader之前会导致Consul 服务不可用。

    Eureka和Nacos的区别：
    答： Eureka只能遵从AP原则，Nacos同时支持CP和AP原则，支持切换，AP模式下服务以临时实例注册，CP模式下服务以永久实例注册，Nacos集成了配置中心的功能。

synchronized锁升级过程
https://jishuin.proginn.com/p/763bfbd7033f
https://juejin.cn/post/6894099621694406669#heading-11
    JDK 1.6 之后默认是开启偏向锁的，为什么初始化的代码是无锁状态，进入同步块产生竞争就绕过偏向锁直接变成轻量级锁了呢？
    虽然默认开启了偏向锁，但是开启有延迟，大概 4s。原因是 JVM 内部的代码有很多地方用到了synchronized，如果直接开启偏向，
    产生竞争就要有锁升级，会带来额外的性能损耗，所以就有了延迟策略

    延迟5秒创建对象后，匿名偏向状态，是对象初始化中，JVM 帮我们做的
    这样当有线程进入同步块：
    biased(0：不可偏向状态, 1:不可偏向状态)
        可偏向状态：直接就 CAS 替换 ThreadID，如果成功，就可以获取偏向锁了
        不可偏向状态：就会变成轻量级锁

    那问题又来了，现在锁对象有具体偏向的线程，如果新的线程过来执行同步块会偏向新的线程吗？

    在真正讲解偏向撤销之前，需要和大家明确一个概念——偏向锁撤销和偏向锁释放是两码事
        撤销：笼统的说就是多个线程竞争导致不能再使用偏向模式的时候，主要是告知这个锁对象不能再用偏向模式
        释放：和你的常规理解一样，对应的就是 synchronized 方法的退出或 synchronized 块的结束

    何为偏向撤销？
        从偏向状态撤回原有的状态，也就是将 MarkWord 的第 3 位（是否偏向撤销）的值，从 1 变回 0

    如果只是一个线程获取锁，再加上「偏心」的机制，是没有理由撤销偏向的，所以偏向的撤销只能发生在有竞争的情况下

    想要撤销偏向锁，还不能对持有偏向锁的线程有影响，所以就要等待持有偏向锁的线程到达一个 safepoint 安全点
    (这里的安全点是 JVM 为了保证在垃圾回收的过程中引用关系不会发生变化设置的一种安全状态，在这个状态上会暂停所有线程工作)，
    在这个安全点会挂起获得偏向锁的线程

    线程不存活或者活着的线程但退出了同步块，很简单，直接撤销偏向就好了
    活着的线程但仍在同步块之内，那就要升级成轻量级锁

    一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。
    这种case下，会导致大量的偏向锁撤销操作
    明知有多线程竞争（生产者/消费者队列），还要使用偏向锁，也会导致各种撤销

    很显然，这两种场景肯定会导致偏向撤销的，一个偏向撤销的成本无所谓，大量偏向撤销的成本是不能忽视的。
    那怎么办？既不想禁用偏向锁，还不想忍受大量撤销偏向增加的成本，这种方案就是设计一个有阶梯的底线

    批量重偏向（bulk rebias）
        这是第一种场景的快速解决方案，以 class 为单位，为每个 class 维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器 +1，当这个值达到重偏向阈值（默认20）时：
        JVM 就认为该class的偏向锁有问题，因此会进行批量重偏向, 它的实现方式就用到了我们上面说的 epoch

    Epoch，如其含义「纪元」一样，就是一个时间戳。每个 class 对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word 中也有该字段，
        就是一时间戳，用来验证是否偏向过期的
    其初始值为创建该对象时 class 中的epoch的值（此时二者是相等的）。
    每次发生批量重偏向时，就将该值加1，同时遍历JVM中所有线程的栈,找到该 class 所有正处于加锁状态的偏向锁对象，将其epoch字段改为新值
    class 中不处于加锁状态的偏向锁对象（没被任何线程持有，但之前是被线程持有过的，这种锁对象的 markword 肯定也是有偏向的），保持 epoch 字段值不变

    这样下次获得锁时，发现当前对象的epoch值和class的epoch不一样，本着今朝不问前朝事的原则（上一个纪元），
    那就算当前已经偏向了其他线程(个人理解：epoch值不一样，说明之前批量重偏向时，当时这个是不处于加锁状态的偏向锁对象，epoch值没有被加1)，也不会执行撤销操作，
    而是直接通过 CAS 操作将其mark word的线程 ID 改成当前线程 ID，这也算是一定程度的优化，毕竟没升级锁；
    疑问：为什么这里可以CAS,如果已经偏向了其他线程，为什么不算竞争，而可以直接CAS?
        不匹配，则表明偏向已过期，需要重新偏向,即这个对象目前偏向的线程id是过期的，相当于没有偏向某个线程，所以可以cas

    如果 epoch 都一样，说明发生过批量重偏向（当前对象是有偏向线程的，那么其他锁来竞争，就要升级锁）, 如果 markword 有线程ID，还有其他锁来竞争，那锁自然是要升级的(如同前面举的例子 epoch=0)

    批量重偏向是第一阶梯底线，还有第二阶梯底线
    批量撤销（bulk revoke）
        当达到重偏向阈值后，假设该 class 计数器继续增长，当其达到批量撤销的阈值后（默认40）时，
        JVM就认为该 class 的使用场景存在多线程竞争，会标记该 class 为不可偏向。
        之后对于该 class 的锁，直接走轻量级锁的逻（个人理解：把biased:可偏向状态1改为不可偏向状态0）

        这就是第二阶梯底线，但是在第一阶梯到第二阶梯的过渡过程中，也就是在彻底禁用偏向锁之前，还给一次改过自新的机会，那就是另外一个计时器：
            1.如果在距离上次批量重偏向发生的 25 秒之内，并且累计撤销计数达到40，就会发生批量撤销（偏向锁彻底 game over）
            2.如果在距离上次批量重偏向发生超过 25 秒之外，那么就会重置在 [20, 40) 内的计数, 再给次机会

轻量级锁
    使用场景：
        如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化
    创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一 个锁记录的结构，内部可以储存锁定对象的Mark Word
        1.复制 mark word 到 displace mark word（Lock Record）（复制过来是做一个记录，因为后面要把锁对象头的标记字段的值替换为刚才复制这个标记字段的空间地址）
        2.CAS 替换 mark word 中的信息为指针 (指向Lock Record)
        3.修改 锁 标志为 00
        4.将栈帧中的 owner 指向锁定的对象 （Owner：当前已经获取到所资源的线程被称为Owner）
    若当前只有一个等待线程，则该线程通过自旋进行等待。
    但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
    重入：
        线程 A 在去获取轻量级锁的时候，会首先使用 CAS 操作，如果操作失败那么会在此时判断是不是该线程已经持有过该对象的锁了，
        通过判断对象的 mark word 是不是指向当前线程的栈帧，如果是则会在最新的栈帧处新建一个 displaced mark word 为 null 的 lock record。
        关于为什么要这么做，其实就是为了记录一下锁的重入，发生重入了需要记录，本来是记录到 mark word 里面最方便，可能是 mark word 没有足够的空间。
        如果是在 lock record里面记录的话，需要遍历 lock record 才可以获取这个数量。所以最终Hotspot选择每次获得锁都添加一个Lock Record来表示锁的重入。

        类似的递归的解锁只需要将栈帧中的 lock records 删除即可。、

    轻量级锁 解锁
        1.轻量级锁解锁也是理由 CAS 将 mark word 里面的指针替换为无锁的 mark word 信息。
        2.需要判断 mark word 里面的指针是不是指向该线程的 lock record
            如果不是，说明已经锁膨胀了，CAS 失败，此时需要唤醒在等待重量级锁的线程
            如果是，说明锁没有膨胀，直接 CAS 操作将 mark word 改为 001（无锁）状态，为下一个线程获取轻量级锁做好准备。

重量级锁
    重量级就是我们平常说的加的同步锁，也就是java基础的锁实现，获取锁与释放锁的时候都要进行系统调用，从而导致上下文切换。
重量级锁 解锁
    释放 mutex，唤醒在等待的线程

synchronized原理，锁的升级
并发编程
    https://juejin.cn/post/6907509476060823565

// Stream流式运算原理与使用详解
https://blog.csdn.net/TonyStarkF/article/details/122882539

redis底层数据结构

eureka
服务注册
思考？你怎么实现
学到设计理念
    Eureka多级缓存设计(解决读写冲突)
    自我保护机制(防止网络抖动)

submit()
execute()
    execute()只能执行实现Runnable接口类型的任务;而submit()不仅可以执实现Runnable类型接口的任务，也可以执行实现Callable接口类型的任务
    execute()没有返回值，而submit()有在添加Callable类型任务的时候有返回值，我们一般通过返回值查看线程执行情况。
    如果线程执行发生异常，submit可以通过Future.get()方法抛出异常，方便我们自定义异常处理；而execute()会终止异常，没有返回值
    总结：两者主要区别，其实还是在于有无返回值，实际生产中为了更好的处理异常，使用submit更多一点。

怎么理解spring Boot的约定优于配置
    什么是约定优于配置？
    为什么springBoot是约定优于配置的实现（体现在哪些方面）
    Spring-boot-Starter-Web
        Tomcat
        添加Spring MVC
    application.properties
    默认的Maven项目结构
    自动装配



为什么不用zk，二用nacos
    两个层次，初级层面，从应用层面去回答两个组件的差异
    高级层次，技术选型

    功能差异
        Nacos提供配置中心和注册中心的功能
        zk 分布式协调（分布式锁） 可以实现配置中心和注册中心
    特性
        数据的同步？nacos作为配置中心，长轮询，nacos注册中心，pull+push
        集群？nacos配置中心，广播，nacos注册中心，ap(distro) cp(raft)
        zk zab协议
    数据存储
        nacos作为配置中心，使用derby,Mysql持久化
        zk 基于磁盘的持久化
    开源程度
        nacos是阿里维护的
        zk是Apache基金会的项目

cpu飙高，系统反应慢怎么排查？
    考察解决实际问题的能力
    多线程领域的知识
    系统资源使用的分析能力

    cpu高可能的原因有哪些？
    什么情况下cpu资源被大量应用
        full gc
        挖矿
        context(上下文)切换
        死循环
        线程使用过多

    top找到进程，再定位到线程
    jStack获取线程dump日志


@Autowired和@Resource有什么区别

静态数据 CDN

数据库事务的执行流程
单表查询用到了几个索引
    最后给我解释的是, 数据库会选用最优的索引
事务的实现
Left join又用到了几个索引
XA缺点
二阶段三阶段区别