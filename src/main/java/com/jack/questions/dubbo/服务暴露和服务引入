服务暴露流程
1.服务的暴露起始于 Spring IOC 容器刷新完毕之后，会根据配置参数组装成 URL， 然后根据 URL 的参数来进行本地或者远程调用。
2.会通过 proxyFactory.getInvoker获取到invoker，然后用动态代理，封装真的实现类，然后再通过 URL 参数选择对应的协议来进行 protocol.export，默认是 Dubbo 协议。
3.在第一次暴露的时候会调用 createServer 来创建 Server，默认是 NettyServer。
4.然后将 export 得到的 exporter 存入一个 Map 中，供之后的远程调用查找，然后会向注册中心注册提供者的信息。
---------------------------------------------------------------------------------------------------------------
export(暴露) ，protocol(协议)，ProxyFactory（代理工厂），invoker（执行器）
1.在容器启动的时候，通过ServiceConfig解析标签，创建dubbo标签解析器来解析dubbo的标签，容器创建完成之后，触发ContextRefreshEvent事件回调开始暴露服务
    Spring IOC 容器刷新完毕之后，会根据配置参数组装成 URL
2.通过ProxyFactory获取到invoker，invoker包含了需要执行的方法的对象信息和具体的URL地址
    利用代理工厂获取执行器（接口和接口实现类对象的执行者，执行者就是把实现对象和url地址包装了一下，组合成了一个invoker）
3.再通过DubboProtocol的实现把包装后的invoker转换成exporter（暴露器），然后启动服务器server，监听端口
    在第一次暴露的时候会调用 createServer 来创建 Server
    openServer(url),创建服务器，其实就是启动netty服务器，监听端口
4.最后RegistryProtocol保存URL地址和invoker的映射关系，同时注册到服务中心
    保存到注册表里面，注册表里面缓存了url地址，对应哪个服务的执行器，执行器里面有真正的服务
    调用的时候根据url地址对应哪个执行器，就可以拿到这个执行器


服务引入流程
1.会先根据配置参数组装成 URL ，一般而言我们都会配置的注册中心，所以会构建 RegistryDirectory 向注册中心注册消费者的信息，并且订阅提供者、配置、路由等节点。
2.得知提供者的信息之后会进入 Dubbo 协议的引入，会创建 Invoker ，期间会包含 NettyClient，来进行远程通信，最后通过 Cluster 来包装 Invoker，默认是 FailoverCluster，最终返回代理类。
---------------------------------------------------------------------------------------------------------------
1.首先客户端根据配置文件信息从注册中心订阅服务
2.之后DubboProtocol根据订阅得到provider地址和接口信息连接到服务端server（拿到netty传输器连接），开启客户端client，然后创建invoker
3.dubbo远程引用Service，Service在注册中心订阅到的地址，核心是获取客户端
invoker创建完成之后，通过invoker为服务接口生成代理对象，这个代理对象用于远程调用provider，服务的引用就完成了
核心就是代理对象里面有跟远程能建起连接的客户端，也有远程服务的url地址信息


服务调用的流程？
    就是引用服务为我们创建出消费者代理对象，代理对象如何进行方法调用
消费者调用某个接口的方法会调用之前生成的代理类，然后会从 cluster 中经过路由的过滤、负载均衡机制选择一个 invoker 发起远程调用，此时会记录此请求和请求的 ID 等待服务端的响应。
服务端（生产者）接受请求之后会通过参数找到之前暴露存储的 map，得到相应的 exporter ，然后最终调用真正的实现类，再组装好结果返回，这个响应会带上之前请求的 ID。
消费者收到这个响应之后会通过 ID 去找之前记录的请求，然后找到请求之后将响应塞到对应的 Future 中，唤醒等待的线程，最后消费者得 到响应，一个流程完毕。
关键的就是 cluster、路由、负载均衡，然后 Dubbo 默认是异步的，所以请求和响应是如何对应上的。