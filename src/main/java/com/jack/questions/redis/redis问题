本地缓存和 redis缓存有什么不同？
redis分布式 扩容缩容是着呢吗做的？
redis热点key处理，
redis如何淘汰过期key的，
redis展示所有key的命令，
redis和数据库同步,
redis为啥比较快，
redis为什么快？
    不过与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快

redis内部是单线程的，真的吗？那redis的rdb和aof呢？
    不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。
    大体上来说，Redis 6.0 之前主要还是单线程处理。
    那，Redis6.0 之前 为什么不使用多线程？
    我觉得主要原因有下面 3 个：
    单线程编程容易并且更容易维护；
    Redis 的性能瓶颈不在 CPU ，主要在内存和网络；
    多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

    Redis6.0 之后为何引入了多线程？
    Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。
    虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。



Redis基本的数据类型，底层的数据结构是什么？
    string
        介绍 ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（simple dynamic string，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。
        常用命令： set,get,strlen,exists,decr,incr,setex 等等。
        应用场景： 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。
    list
        介绍 ：list 即是 链表。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。
        常用命令: rpush,lpop,lpush,rpop,lrange,llen 等。
        应用场景: 发布与订阅或者说消息队列、慢查询。
    hash
        介绍 ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。
        常用命令： hset,hmset,hexists,hget,hgetall,hkeys,hvals 等。
        应用场景: 系统中对象数据的存储
    set
        介绍 ： set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。
        常用命令： sadd,spop,smembers,sismember,scard,sinterstore,sunion 等。
        应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景
    sorted set
        介绍： 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。
        常用命令： zadd,zcard,zscore,zrange,zrevrange,zrem 等。
        应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息
    bitmap
        介绍： bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。
        常用命令： setbit 、getbit 、bitcount、bitop
        应用场景： 适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）
Redis的缓存雪崩，缓存穿透，缓存击穿这三种场景有没有了解
Memcache有过了解吗
    共同点 ：
        都是基于内存的数据库，一般都用来当做缓存使用。
        都有过期策略。
        两者的性能都非常高。
    区别 ：
        1.Redis 支持更丰富的数据类型（支持更复杂的应用场景）
        2.Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。
        3.Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。
        4.Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。
        5.Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。
        6.Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 引入了多线程 IO ）
数据有1百万条，保留热门数据，Redis只能保留20w条数据，你想怎么实现
redis是nio还是aio
redis持久化方式
缓存雪崩穿透
    缓存穿透
    缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。
    举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。
    1）缓存无效 key
        这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。
    2）布隆过滤器
        https://javaguide.cn/cs-basics/data-structure/bloom-filter/#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D
        布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在
    缓存雪崩
        缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求
        针对 Redis 服务不可用的情况：
            采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
            限流，避免同时处理大量的请求。
        针对热点缓存失效的情况：
            设置不同的失效时间比如随机设置缓存的失效时间。
            缓存永不失效
    缓存击穿
        缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
        解决方案：
        设置热点数据永远不过期。
        加互斥锁
redis和mysql的一致性
    https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd
    推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做
    拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。
    订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：
    无需考虑写消息队列失败情况：只要写 MySQL 成功，Binlog 肯定会有

    问题1：延迟时间要大于「主从复制」的延迟时间
    问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间
redis key删除策略
    如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？

    常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：

    惰性删除 ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
    定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。
    定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性/懒汉式删除 。

    但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。

    怎么解决这个问题呢？答案就是：Redis 内存淘汰机制。
内存淘汰机制
    volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
    volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
    volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
    allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
    allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
    no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！
    4.0 版本后增加以下两种：

    volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰
    allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key
    Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)