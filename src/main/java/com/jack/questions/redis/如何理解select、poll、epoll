select、poll 和 epoll 都是 I/O 多路复用的机制，用于实现高效的事件驱动 I/O 模型，特别是在网络编程中。

select：
    select 是最早出现的 I/O 多路复用机制之一，它允许程序监视一组文件描述符，一旦其中任何一个文件描述符就绪（可读、可写、异常等），就通知程序进行相应的 I/O 操作。
    select 的缺点是效率低下，它将要监视的文件描述符集合从用户态拷贝到内核态，每次调用都需要将文件描述符集合从用户态拷贝到内核态，效率随着监视的文件描述符数量的增加而下降。

poll：
    poll 与 select 类似，也是用于监视一组文件描述符的状态变化。不同之处在于，poll 没有 select 的文件描述符数量限制，也没有使用 fd_set 这种数据结构，而是采用了普通的数组。
    poll 与 select 一样存在效率低下的问题，因为它需要将文件描述符集合从用户态拷贝到内核态，每次调用都会导致数据的复制。

epoll：
    epoll 是 Linux 特有的高效 I/O 多路复用机制，可以显著提高程序的性能。
    epoll 采用了事件就绪通知的方式，而不是像 select 和 poll 那样轮询文件描述符集合。它将文件描述符的状态保存在内核的事件表中，通过 epoll_ctl 控制事件的注册和删除，通过 epoll_wait 等待事件的发生。
    epoll 的优势在于它避免了每次调用都需要将文件描述符集合从用户态拷贝到内核态的开销，以及不再受到文件描述符数量的限制，适用于高并发的网络编程场景。
    总的来说，select、poll 和 epoll 都是用于实现 I/O 多路复用的机制，但是它们的实现原理和性能特点不同，epoll 在处理大量并发连接时性能更高，是开发高性能网络服务器的首选

为什么select每次调用都需要将文件描述符集合从用户态拷贝到内核态？
    因为select的read、write、exception三个fd_set集合是在用户态的，而内核态需要这些集合来判断哪些文件描述符就绪了，所以需要将这些集合从用户态拷贝到内核态。
    这些参数是指针类型，指向用户态的内存地址