一、复习链表
1.1 数组与链表
    数组需要一块连续的内存来存储，这个特性有利也有弊。
    好处是其支持根据索引下标"随机访问"(时间复杂度为O(1))，但是其插入与删除操作为了保证在内存中的连续性将会变得非常低效(时间复杂度为O(N))，
    并且其一经声明就要占用整块连续内存空间，如果声明过大，系统可能内存不足，
    声明过小又可能导致不够用，而当数组的空间不足的时候需要对其进行扩容(申请一个更大的空间，将原数组拷贝过去)。

    而链表恰恰相反，其不需要一块连续的内存空间，其通过"指针"将一组零散的内存连接起来使用。
    其优点在于本身没有大小限制，天然支持扩容，插入删除操作高效(时间复杂度为O(1))，但缺点是随机访问低效(时间复杂度为O(N))。并且由于需要额外的空间存储指针


二、Redis链表#
2.1 双向无环链表#
    Redis链表使用双向无环链表。
typedef struct listNode
{
	// 前置节点
	struct listNode *prev;
	// 后置节点
	struct listNode *next;
	// 节点的值
	void *value;
} listNode;

2.2 list结构#
    同时Redis为了方便的操作链表，提供了一个list结构来持有链表。如下图所示

    typedef struct list{
        //表头节点
        listNode *head;
        //表尾节点
        listNode *tail;
        //链表所包含的节点数量
        unsigned long len;
        //节点值复制函数
        void *(*dup)(void *ptr);
        //节点值释放函数
        void *(*free)(void *ptr);
        //节点值对比函数
        int (*match)(void *ptr,void *key);
    }list;

Redis链表结构其主要特性如下:
    双向：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为0(1)。
    无环: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向NULL，对链表的访问以NULL为终点。
    带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)。
    带链表长度计数器:通过list结构的len属性获取节点数量的时间复杂度为O(1)。
    多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值

2.3 双向无环链表在redis中的使用
列表表对象的底层实现之一就是链表。此外如发布订阅、慢查询、监视器等功能也用到了链表。
我们现在简单想一想Redis为什么要使用双向无环链表这种数据结构，而不是使用数组、单向链表等。

在列表对象中常用的操作中双向链表的优势所在。但双向链表因为使用两个额外的空间存储前驱和后继指针，因此在数据量较小的情况下会造成空间上的浪费(因为数据量小的时候速度上的差别不大，但空间上的差别很大)。
这是一个时间换空间还是空间换时间的思想问题，Redis在列表对象中小数据量的时候使用压缩列表作为底层实现，而大数据量的时候才会使用双向无环链表

