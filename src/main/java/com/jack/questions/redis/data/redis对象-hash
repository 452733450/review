https://www.cnblogs.com/hunternet/p/12651530.html
哈希类型的内部编码有两种：ziplist(压缩列表),hashtable(哈希表)。
只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：
    当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）
    所有值都小于hash-max-ziplist-value配置（默认64字节）
    ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。
    当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，
    * 因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。


它有点儿类似数组，通过一片连续的内存空间，来存储数据。
不过，它跟数组不同的一点是，它允许存储的数据大小不同。

数组的优势占用一片连续的空间可以很好的利用CPU缓存存访问数据。
如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩

压缩列表(zip1ist)是列表和哈希的底层实现之一。
    当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。
    当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。

三、适用场景
3.1 存储对象
    Redis哈希对象常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等。
特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等