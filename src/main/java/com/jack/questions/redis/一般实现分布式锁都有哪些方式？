redis 分布式锁
官方叫做 RedLock 算法，是 redis 官方支持的分布式锁算法。

这个分布式锁有 3 个重要的考量点：
    互斥（只能有一个客户端获取锁）
    不能死锁
    容错（只要大部分 redis 节点创建了这把锁就可以）

    redis 最普通的分布式锁
    第一个最普通的实现方式，就是在 redis 里创建一个 key，这样就算加锁。

    SET my:lock 随机值 NX PX 30000
    执行这个命令就 ok。

    NX：表示只有 key 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 nil）
    PX 30000：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。
    释放锁就是删除 key ，但是一般可以用 lua 脚本删除，判断 value 一样才删除：

    锁被别人释放怎么办?
        解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。
        这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。

        客户端 1 执行 GET，判断锁是自己的
        客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）
        客户端 1 执行 DEL，却释放了客户端 2 的锁
        由此可见，这两个命令还是必须要原子执行才行。
        因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，
        直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。

    死锁：设置过期时间
    过期时间评估不好，锁提前过期：守护线程，自动续期
    锁被别人释放：锁写入唯一标识，释放锁先检查标识，再释放


    RedLock 算法
    这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：

    获取当前时间戳，单位是毫秒；
    跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；
    尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；
    客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；
    要是锁建立失败了，那么就依次之前建立过的锁删除；
    只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。

    Redlock 具体如何使用呢？


    整体的流程是这样的，一共分为 5 步：
    客户端先获取「当前时间戳T1」
    客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁
    如果客户端从 >=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 < 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败
    加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）
    加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）


zk 分布式锁
    zk 分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；
    这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个 znode，
    一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。

    如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；
    后面的每个人都会去监听排在自己前面的那个人创建的 node 上，一旦某个人释放了锁，
    排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。

redis 分布式锁和 zk 分布式锁的对比
    redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。
    zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。
    另外一点就是，如果是 redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；
    而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。

redis 分布式锁大家没发现好麻烦吗？遍历上锁，计算时间等等......zk 的分布式锁语义清晰实现简单。