ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，
这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。

我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：
Segment 数组长度为 16，不可以扩容
Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容
这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍
当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到

put 过程分析
// 1. 计算 key 的 hash 值
// 2. 根据 hash 值找到 Segment 数组中的位置 j
//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，
//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标
    ensureSegment(j) 对 segment[j] 进行初始化
        // 这里看到为什么之前要初始化 segment[0] 了,(在构造方法中初始化了segment[0])
        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]
    刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null
    ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。
// 3. 插入新值到 槽 s 中,Segment 内部是由 数组+链表 组成的
Segment#put()
// 在往该 segment 写入前，需要先获取该 segment 的独占锁
// 再利用 hash 值，求应该放置的数组下标
// first 是数组该位置处的链表的表头
        HashEntry<K,V> first = entryAt(tab, index);
for循环这个链表
分该位置没有任何元素和已经存在一个链表这两种情况
如果存在链表，找到一个元素的hash值和key值与要插入的node相同，则用新值覆盖旧值
如果该位置没有任何元素
    // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。
    // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。
    // 如果超过了该 segment 的阈值，这个 segment 需要扩容
    rehash(node);
        // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置
        // 计算应该放置在新数组中的位置，
        // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19
    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，
    // 其实就是将新的节点设置成原链表的表头
    // 该位置处只有一个元素，那比较好办
    // 如果大于一个元素
    则用两个for循环
    第一个for循环
    [0]=null
    [1]=0->1->1->0->0->0->0
    // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的
        for (HashEntry<K,V> last = next;
             last != null;
             last = last.next) {
            int k = last.hash & sizeMask;
            if (k != lastIdx) {
                lastIdx = k;
                lastRun = last;
            }
        }
        遍历每个元素，最后一个节点定为，它的下一个节点在新数组中存放的位置index与它本身不同
        如上面的链表，lastRun是第三个0

        [0]=null
        [1]=1->1->0->0->0->0->1->0
        上面的链表，lastRun是最后一个0
    // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置
    newTable[lastIdx] = lastRun;

    第二个for循环处理lastRun之前的节点
    // 下面的操作是处理 lastRun 之前的节点，
    //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中
    for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
        V v = p.value;
        int h = p.hash;
        int k = h & sizeMask;
        HashEntry<K,V> n = newTable[k];
        newTable[k] = new HashEntry<K,V>(h, p.key, v, n);
    }

    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部
        int nodeIndex = node.hash & sizeMask; // add the new node
        node.setNext(newTable[nodeIndex]);
        newTable[nodeIndex] = node;
        table = newTable;

https://www.zhihu.com/question/60888757
我们在这里稍微总结一下put方法里面最重要的三个细节，首先将volatile变量转为普通变量提升性能，
因为在put中需要读取到最新的数据，因此接下来调用UNSAFE.getObjectVolatile获取到最新的头结点，
但是通过调用UNSAFE.putOrderedObject让变量写入主存的时间延迟到put方法的结尾，一来缩小临界区提升性能，而来也能保证其他线程读取到的是完整数据。


get 过程分析
相对于 put 来说，get 真的不要太简单。

计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”
槽中也是一个数组，根据 hash 找到数组中具体的位置
到这里是链表了，顺着链表进行查找即可