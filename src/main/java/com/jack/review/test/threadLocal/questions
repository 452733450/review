https://segmentfault.com/a/1190000024437984
https://segmentfault.com/a/1190000015191900?utm_source=sf-similar-article
https://www.cnblogs.com/yaofengdoit/p/12676863.html(比较有条理的)
5&4 与操作

        5的二进制是  0000 0000 0000 0101
        4的二进制是  0000 0000 0000 0100
        则结果是     0000 0000 0000 0100  转为十进制是4。

事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，
既然从自己的变量中取值，那肯定就不存在线程安全问题，总体来讲，ThreadLocal这个变量的状态根本没有发生变化，他仅仅是充当一个key的角色，
另外提供给每一个线程一个初始值。

看到这里，我们就知道了原来Threadlocal有一个内部类ThreadlocalMap，对于任何一个线程都会有唯一的一个ThreadlocalMap来对应，而这个map实际并不存储在Threadlocal中，而是存在Thread当中，只不过由Threadlocal暴露了一套api来维护Thread的ThreadLocalMap。
这样设计的好处就是，当线程死掉之后，ThreadLocalMap没有强引用，方便收集器回收。

ThreadLocal和Synchronized都是为了解决多线程中相同变量的访问冲突问题，不同的点是
Synchronized是通过线程等待，牺牲时间来解决访问冲突
ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。


1.Threadlocal 的实现原理？
2.Threadlocal是干什么的?
    Threadlocal 主要用来做线程变量的隔离
3.Threadlocal 怎么实现线程变量的隔离的?
    Thread 类有个 ThreadLocalMap 成员变量，这个Map key是Threadlocal 对象，value是你要存放的线程局部变量。
    在当前线程对象的ThreadlocalMap中put了一个元素(Entry)，key是Threadlocal对象，value是userInfo。

    ThreadLocalMap 类的定义在 Threadlocal中。
    第一，Thread 对象是Java语言中线程运行的载体，每个线程都有对应的Thread 对象，存放线程相关的一些信息，
    第二，Thread类中有个成员变量ThreadlocalMap，你就把他当成普通的Map，key存放的是Threadlocal对象，value是你要跟线程绑定的值（线程隔离的变量），比如这里是用户信息对象（UserInfo）。
4.Thread 类有个 ThreadlocalMap 属性的成员变量，但是ThreadlocalMap 的定义却在Threadlocal 中，为什么这么做？
    ThreadLocalMap 就是为维护线程本地变量而设计的，只做这一件事情,就是让使用者知道ThreadLocalMap就只做保存线程局部变量这一件事的。
5.既然是线程局部变量，那为什么不用线程对象（Thread对象）作为key，这样不是更清晰，直接用线程作为key获取线程变量？
    这样设计会有个问题，比如: 我已经把用户信息存在线程变量里了，这个时候需要新增加一个线程变量，
    比方说新增用户地理位置信息，我们ThreadlocalMap 的key用的是线程，再存一个地理位置信息，key都是同一个线程（key一样），不就把原来的用户信息覆盖了嘛。
6.那新增地理位置信息应该怎么做？
    新创建一个Threadlocal对象就好了，因为ThreadLocalMap的key是Threadlocal 对象，比如新增地理位置，我就再 Threadlocal < Geo> geo = new Threadlocal（）,
    存放地理位置信息，这样线程的ThreadlocalMap里面会有二个元素，一个是用户信息，一个是地理位置。
7.ThreadlocalMap 是什么数据结构实现的？
    跟HashMap 一样，也是数组实现的。
8.ThreadlocalMap 发生hash冲突怎么办？跟HashMap 有什么区别？
    有区别的，对待哈希冲突，HashMap采用的链表 + 红黑树的形式
    ThreadlocalMap既没有链表，也没有红黑树，采用的是开放定址法 ，是这样，是如果发生冲突，ThreadlocalMap直接往后找相邻的下一个节点，如果相邻节点为空，直接存进去，
    如果不为空，继续往后找，直到找到空的，把元素放进去，或者元素个数超过数组长度阈值，进行扩容。
9.我看你最前面图中画的ThreadlocalMap 中key是 WeakReference类型，能讲讲Java中有几种类似的引用，什么区别吗？
    强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它，当内存空间不足时，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
    如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。
    弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描内存区域时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
    虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
10.为什么ThreadlocalMap 中key 设计成 WeakReference（弱引用）类型吗？
    ThreadLocal的设计者考虑到线程往往生命周期很长，比如经常会用到线程池，线程一直存活着，根据JVM 根搜索算法，一直存在 Thread -> ThreadLocalMap -> Entry（元素）这样一条引用链路,
     如下图，如果key不设计成WeakReference类型，是强引用的话，就一直不会被GC回收，key就一直不会是null，不为null Entry元素就不会被清理（ThreadLocalMap是根据key是否为null来判断是否清理Entry）
     所以ThreadLocal的设计者认为只要ThreadLocal 所在的作用域结束了工作被清理了，GC回收的时候就会把key引用对象回收，key置为null，ThreadLocal会尽力保证Entry清理掉来最大可能避免内存泄漏。
11.那如果Threadlocal 对象一直有强引用，那怎么办？岂不是有内存泄漏风险
    最佳实践是用完手动调用remove函数。
    ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，
    如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：ThreadLocal Ref -> Thread -> ThreaLocalMap -> Entry -> value永远无法回收，造成内存泄露。
    其实jdk已经考虑到了这种情况，ThreadLocalMap的genEntry函数或者set函数会去遍历将key为null的给移除掉，但这明显不是所有情况都成立的，
    所以需要调用者自己去调用remove函数，手动删除掉需要的threadlocal，防止内存泄露。
    然后jdk并不建议在栈内声明threadlocal，而是建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，
    由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。

12.为什么entry数组的大小，以及初始容量都必须是2的幂？
    对于 firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1); 以及很多源码里面都是使用 hashCode &（ -1） 来代替hashCode% 。 这种写法好处如下：
    使用位运算替代取模，提升计算效率。
    为了使不同 hash 值发生碰撞的概率更小，尽可能促使元素在哈希表中均匀地散列。

13.ThreadLocalMap只有一个数组，它是怎么来解决hash冲突呢？