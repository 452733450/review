5&4 与操作

        5的二进制是  0000 0000 0000 0101
        4的二进制是  0000 0000 0000 0100
        则结果是     0000 0000 0000 0100  转为十进制是4。

事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，
既然从自己的变量中取值，那肯定就不存在线程安全问题，总体来讲，ThreadLocal这个变量的状态根本没有发生变化，他仅仅是充当一个key的角色，
另外提供给每一个线程一个初始值。

1.Threadlocal 的实现原理？
2.Threadlocal是干什么的?
    Threadlocal 主要用来做线程变量的隔离
3.Threadlocal 怎么实现线程变量的隔离的?
    Thread 类有个 ThreadLocalMap 成员变量，这个Map key是Threadlocal 对象，value是你要存放的线程局部变量。
    在当前线程对象的ThreadlocalMap中put了一个元素(Entry)，key是Threadlocal对象，value是userInfo。

    ThreadLocalMap 类的定义在 Threadlocal中。
    第一，Thread 对象是Java语言中线程运行的载体，每个线程都有对应的Thread 对象，存放线程相关的一些信息，
    第二，Thread类中有个成员变量ThreadlocalMap，你就把他当成普通的Map，key存放的是Threadlocal对象，value是你要跟线程绑定的值（线程隔离的变量），比如这里是用户信息对象（UserInfo）。
4.Thread 类有个 ThreadlocalMap 属性的成员变量，但是ThreadlocalMap 的定义却在Threadlocal 中，为什么这么做？
    ThreadLocalMap 就是为维护线程本地变量而设计的，只做这一件事情,就是让使用者知道ThreadLocalMap就只做保存线程局部变量这一件事的。
5.既然是线程局部变量，那为什么不用线程对象（Thread对象）作为key，这样不是更清晰，直接用线程作为key获取线程变量？
    这样设计会有个问题，比如: 我已经把用户信息存在线程变量里了，这个时候需要新增加一个线程变量，
    比方说新增用户地理位置信息，我们ThreadlocalMap 的key用的是线程，再存一个地理位置信息，key都是同一个线程（key一样），不就把原来的用户信息覆盖了嘛。
6.那新增地理位置信息应该怎么做？
    新创建一个Threadlocal对象就好了，因为ThreadLocalMap的key是Threadlocal 对象，比如新增地理位置，我就再 Threadlocal < Geo> geo = new Threadlocal（）,
    存放地理位置信息，这样线程的ThreadlocalMap里面会有二个元素，一个是用户信息，一个是地理位置。
7.ThreadlocalMap 是什么数据结构实现的？
    跟HashMap 一样，也是数组实现的。
8.ThreadlocalMap 发生hash冲突怎么办？跟HashMap 有什么区别？
    有区别的，对待哈希冲突，HashMap采用的链表 + 红黑树的形式
    ThreadlocalMap既没有链表，也没有红黑树，采用的是开放定址法 ，是这样，是如果发生冲突，ThreadlocalMap直接往后找相邻的下一个节点，如果相邻节点为空，直接存进去，
    如果不为空，继续往后找，直到找到空的，把元素放进去，或者元素个数超过数组长度阈值，进行扩容。