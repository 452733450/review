B+树，
非叶子节点只存储冗余索引
把所有数据地址都放在叶子节点，
叶子节点包含所有的索引字段，
叶子节点用指针连接，提高区间访问性能（指针可以快速找到指针指向的元素，范围查找的时候很有用）

每个叶子节点大概16k
假设用主键索引bigint 8byte

8字节的索引+6字节的空白（磁盘指针地址）
16k/(8+6)byte == 1170

若树高为3

叶子节点索引+数据 假设大概1kb 叶子层大概放16个叶子节点
1170*1170*16 = 2000万个左右

MyIsam索引和数据是放到2个文件存储的
InnoDB索引和数据是放到一个文件存储 test.ibd
innnoDB叶子节点，并不是放的数据的磁盘地址，而是包含了完整的数据记录
聚集索引-》叶子节点包含了完整的数据记录

myisam存储的索引文件就是非聚集索引，它的数据在test.myd里面，索引在test.myi里
InnoDB索引和数据是放到一个文件存储 test.ibd
myisam的主键索引就是非聚集索引，innodb的主键索引就是聚集索引

聚簇索引与非聚簇索引
聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，

回表
当mysql查询时，使用非聚簇索引（也叫二级索引，辅助索引） 查到相应的叶子节点获取主键值，
然后通过 主键索引（聚簇索引） 再查到相应的数据行信息，找到主键后通过聚簇索引 找到相应数据行的过程叫做回表。

innodb如果不建主键，会默认找一个唯一的索引，建立主键索引，如果没有找到唯一的，mysql会维护一个隐藏列，自增的整型数据 比如rowid，用b+数据索引维护整张表的数据

hash索引
对索引的key进行一次hash计算就可以定位出数据存储的位置
仅能满足"=", "in"查找，不支持范围查询
hash冲突问题


b树和b+树的区别
b树
叶子节点具有相同的深度，叶节点的指针为空（没办法很好的支持范围查找）
所有索引元素不重复
节点中的数据索引从左到右递增排列
b+树
非叶子节点不存储data，只存储索引（冗余），为了可以存储更多的索引
叶子节点包含所有索引字段
叶子节点用指针连接，提高区间访问的性能


主键如果不用自增的，是不是就会导致叶子节点分裂，平衡b树，效率没自增的高

最左前缀原则
其原理是：

b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的。
比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；
但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。
比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性

索引失效
模型数空运最快
模糊查询
数据类型
函数
null
运算
最左
全表扫描更快
1.有or必全有索引;
2.复合索引未用左列字段;
3.like以%开头;
4.需要类型转换;比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5.where中索引列有运算;
6.where中索引列使用了函数;
7.如果mysql觉得全表扫描更快时（数据少）;


 sql语句优化：
1.开启慢查询日志（my.conf,slow_query_log,long_query_time）
2.sql语句尽可能简单，把大的sql语句拆成小的sql语句，一条大的sql语句有可能堵死整个库
3.不同select*,少用join，尽量避免使用like模糊查询, 避免不了也不要使用%开头
4.避免在where子句中使用!=,>,<，因为两种方式都会使得索引失效，从而导致扫描全表
5.使用exists或in查询两张表时，子查询表大的用exists，子查询表小的用in
6.不做列运算，任何针对列的运算都会导致扫描全表，如函数，数学表达式，因此，要把列运算放在等号的右边
7.相同类型的数据进行比较
8.连续数值用betwween
9.列表数据不要拿全表，用limit进行分页，一页的量也不要太大
10.不使用函数和触发器，在应用程序实现
系统调优参数
升级硬件
分库分表
读写分离
也是目前常用的优化，从库读主库写,aop实现主从表读写分离
缓存

1.当IN后面的条件比较少的时候，走索引
2.当IN后面的条件超过某个阈值的时候，开始走全表扫描