https://www.jianshu.com/p/5097fde06d50
https://blog.csdn.net/a745233700/article/details/110914620
https://www.jianshu.com/p/8bb67ca11831
https://zhuanlan.zhihu.com/p/84267654

一级缓存：单例池
/** 保存所有的singletonBean的实例 */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);

二级缓存：未完成单例集
/** 保存所有早期创建的Bean对象，这个Bean还没有完成依赖注入 */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);
三级缓存：单例工厂集
/** singletonBean的生产工厂*/
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);

/** 保存所有已经完成初始化的Bean的名字（name） */
private final Set<String> registeredSingletons = new LinkedHashSet<String>(64);

/** 标识指定name的Bean对象是否处于创建状态  这个状态非常重要 */
private final Set<String> singletonsCurrentlyInCreation =
    Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>(16));


总结，Spring 就是靠获取未完成的Bean对象来填充属性，解决循环依赖的。

为什么不直接把对象放入 earlySingletonObjects，而是先放入 singletonFactories 中？
创建对象是需要消耗性能的，假如创建没有循环依赖的对象，是不需要创建未完成的Bean对象的，所以不是直接创建未完成对象放入未完成单例集 earlySingletonObjects，而是把未完成单例工厂放入 singletonFactories。
比如以下这段代码，在运行时就不会调用 getSingleton 中的 ObjectFactory.getObject() 方法来创建 TestService 未完成 Bean 对象。


说了这么多，总结下三级缓存：

第一级缓存（也叫单例池）：Map<String, Object> singletonObjects，存放已经经历了完整生命周期的 Bean 对象

第二级缓存：Map<String, Object> earlySingletonObjects，存放早期暴露出来的 Bean 对象，Bean 的生命周期未结束（属性还未填充完），可能是代理对象，也可能是原始对象

第三级缓存：Map<String, ObjectFactory<?>> singletonFactories，存放可以生成 Bean 的工厂，工厂主要用来生成 Bean 的代理对象

自我总结：
spring 使用了三级缓存来解决循环依赖
1.singleObjects:保存经历了完整生命周期的bean
2.earlySingleObjects:存放早期暴露出来的bean，bean的生命周期未结束（属性未装配），可以是原对象bean，也可以是代理对象
3.singletonFactories:singletonBean对应的生产工厂
A依赖B，B依赖A
    A在实例化之后，装备属性前，把实例化后的A放入三级缓存，
        this.addSingletonFactory(beanName, () -> {
                        return this.getEarlyBeanReference(beanName, mbd, bean);
                                // 第一步：根据 beanName 将它对应的实例化后且未初始化完的 Bean，存入 Map<Object, Object> earlyProxyReferences = new ConcurrentHashMap<>(16)
                                this.earlyProxyReferences.put(cacheKey, bean);
                                // 第二步：生成该 Bean 对应的代理类返回
                                return this.wrapIfNecessary(bean, beanName, cacheKey);
                                    this.isInfrastructureClass(bean.getClass())
                                        boolean retVal = Advice.class.isAssignableFrom(beanClass) || Pointcut.class.isAssignableFrom(beanClass) || Advisor.class.isAssignableFrom(beanClass) || AopInfrastructureBean.class.isAssignableFrom(beanClass);
                                            A.class.isAssignableFrom(B.class) 判断B是不是A的子类或者子接口
                    });
        装配属性时，需要注入B,这时再去调用getBean(B),走第二个getSingleton()
        B在实例化之后，装配属性时，需要注入A，这时候再去调用getBean(A),这时候走第一个getSingleton()
A先调用getBean(A)
doCreateBean()
    getSingleton(beanName,allowEarlyReference)
    先尝试从一级缓存中获取成品的目标对象，如果存在，则直接返回，
    如果缓存中不存在目标对象，则判断当前对象是否已经处于创建过程中，如果在创建中，尝试从二级缓存中去获取
    二级缓存中如没有，则判断这个bean是否允许循环依赖，如允许，则继续依次尝试一，二，三级缓存中去获取，且这个过程是加锁的，如果在三级缓存中获取到了
    把它放入二级缓存，并从三级缓存中移除

    从第一个getSingleton(beanName,allowEarlyReference)没有获取到
    则通过第二个getSingleton(String beanName, ObjectFactory<?> singletonFactory)来创建
        从三级缓存中获取bean，然后放入一级缓存


二级缓存有什么问题？
如果 Bean 没有 AOP，那么用二级缓存其实没有什么问题的，一旦有上述生命周期中第四步，就会导致的一个问题。因为 AOP 处理后，往往是需要生成代理对象的，代理对象和原来的对象根本就不是 1 个对象。
生成 a 的实例，然后放入缓存，a 需要 b
再生成 b ，填充 b 的时候，需要 a，从缓存中取到了 a，完成 b 的初始化；
紧接着 a 把初始化好的 b 拿过来用，完成 a 的属性填充和初始化
由于 A 类涉及到了 AOP，再然后 a 要生成一个代理类，这里就叫：代理 a 吧
结果就是：a 最终的产物是代理 a，那 b 中其实也应该用代理 a，而现在 b 中用的却是原始的 a 代理 a 和原始的 a 不是一个对象，现在这就有问题了。





