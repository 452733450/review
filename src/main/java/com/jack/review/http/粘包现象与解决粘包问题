粘包现象与解决粘包问题
一、粘包现象介绍
1.socket收发消息的原理
    其实我们发送数据并不是直接发送给对方, 而是应用程序将数据发送到本机操作系统的缓存里边,
     当数据量小, 发送的时间间隔短, 操作系统就会在缓存区先攒够一个TCP段再通过网卡一起发送,
     接收数据也是一样的, 先在操作系统的缓存存着, 然后应用程序再从操作系统中取出数据
1.1缓冲区的作用：存储少量数据
    如果你的网络出现短暂的异常或波动，接受数据就会出现短暂的中断，影响你的下载或者上传的效率，
    但是缓冲区解决了上传下载的传输效率的问题，带来了粘包问题
1.2收发的本质：不一定是一收一发
2.为什么产生黏包
    主要原因 : TCP称为流失协议, 数据流会杂糅在一起, 接收端不清楚每个消息的界限, 不知道每次应该去取多少字节的数据
    次要原因 : TCP为了提高传输效率会有一个nagle优化算法, 当多次send的数据字节都非常少,
        nagle算法就会将这些数据合并成一个TCP段再发送, 这就无形中产生了黏包

3.什么是粘包？
    接收方没有及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，
        服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）recv会产生黏包（如果recv接受的数据量(1024)小于发送的数据量，
        第一次只能接收规定的数据量1024，第二次接收剩余的数据量）
    发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据也很小，会合到一起，产生粘包）send 也可能发生粘包现象。
        （连续send少量的数据发到输出缓冲区，由于缓冲区的机制，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络）

注意：粘包不一定发生，如果发生了：
    可能是在客户端已经粘了。
    客户端没有粘，可能是在服务端粘了。

二、解决粘包问题的两种方式
1、通过send数据长度的方式来控制接收（low版）
    粘包问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕如何让发送端在发送数据前，
        把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据。
为何low？
    效率低 : 程序运行的速度远快于网络传输的速度, 如果在发送真实数据之前先send该数据的字节流长度, 那么就会放大网络延迟带来的性能损耗

2、使用 struct 模块实现精准数据字节接收(比较高效解决tcp协议的黏包方法)
    解决粘包问题的核心就是：为字节流加上一个自定义固定长度的报头, 报头中就包含了该字节流长度,
    然后只需要将整个数据加报头 send 一次到对端, 对端先取出固定长度的报头, 然后在取真实的数据

3、UDP没有粘包问题
udp 被称为数据报协议, 每次发送的数据都是一个数据报, 一次 sendto 对应一次 recvfrom, 不会产生黏包
udp 又被称为不可靠协议, 不可靠在哪里? 比如发送方发送了 10bytes 的数据, 而接收方只接收 8bytes 的数据, 那么剩下的两个 bytes 将会被丢弃, 并且在不同的平台有不同的表现, 下面我们来进行试验 :
