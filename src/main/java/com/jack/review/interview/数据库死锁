线上大量报警
    Deadlock found when trying to get lock;
    定位到SQL语句

发生死锁的表 资金流水表
    聚簇索引 主键索引
    客户id索引
    (客户id，流水单号前20位)联合索引，前缀索引(流水单号取了前20位做前缀索引)
一个sql是根据主键id和用户id更新 托管平台返回的流水单号 64位varchar
另个一sql是根据用户id和流水单号更新流水状态

查看死锁日志
    show engine innodb status

    两个事务持有的锁都为排他锁
    lock_mode X locks rec but not gap
    该代码的目的是先后修改同一个记录的两个不同字段

    分别执行两条sql执行计划
        更新单号用的主键索引
        更新状态用的单号索引
    MySQL中行级锁并不是直接锁记录，而是锁索引。
    如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引
    如果一条sql语句操作了非主键索引，MySQL会先索引该非主键索引，再锁定相关的主键索引

    事务1执行更新单号操作，持有主键索引1
    事务2执行更新单号操作，持有主键索引2
    事务1执行更新状态操作，持有单号索引，并去锁定主键索引2(因为单号索引一样)，阻塞了，因为主键索引2被事务2持有
    事务2执行更新状态，尝试占有单号索引，但是单号索引被事务1持有，这就死锁了

    发现updateStatus是有两个索引可以用的

    所有update都通过主键ID进行
    在同一个事务中，避免出现多条update语句修改同一条记录