mysql导出数据量太大会有什么问题
查看内存使用情况，不用dump文件吗，这么看
怎么去查看运行中的程序，内存大小，堆栈信息,不用dump，怎么快速看到系统的线程数量还有运行的情况，jmap看不了
java8的并行流用过吗，并行得比较多的话，会有什么问题
    https://www.nowcoder.com/discuss/611892?channel=-1&source_id=discuss_terminal_discuss_sim_nctrack
并行流就是把内容分成多个数据块，使用不同的线程分别处理每个数据块的流。
这也是流的一大特点，要知道，在 Java 7 之前，并行处理数据集合是非常麻烦的，你得自己去将数据分割开，自己去分配线程，必要时还要确保同步避免竞争

Stream 让程序员能够比较轻易地实现对数据集合的并行处理，但要注意的是，不是所有情况的适合，
有些时候并行甚至比顺序进行效率更低，而有时候因为线程安全问题，还可能导致数据的处理错误，因此并行的性能问题非常值得我们思考。
比方说下面这个例子
 int i = Stream.iterate(1, a -> a + 1).limit(100).parallel().reduce(0, Integer::sum);
 我们通过这样一行代码来计算 1 到 100 的所有数的和，我们使用了 parallel 来实现并行。
 但实际上是，这样的计算，效率是非常低的，比不使用并行还低！一方面是因为装箱问题，这个前面也提到过，就不再赘述，
 还有一方面就是 iterate 方法很难把这些数分成多个独立块来并行执行，因此无形之中降低了效率。

13.2 顺序性
除了可分解性，和刚刚提到的装箱问题，还有一点值得注意的是一些操作本身在并行流上的性能就比顺序流要差，
比如：limit，findFirst，因为这两个方法会考虑元素的顺序性，而并行本身就是违背顺序性的，也是因为如此 findAny 一般比 findFirst 的效率要高
如果流中的数据量足够大，并行流可以加快处速度。
除了直接创建并行流，还可以通过parallel()把顺序流转换成并行流：
Optional<Integer> findFirst = list.stream().parallel().filter(x->x>6).findFirst();

stream和parallelStream的简单区分：
     stream是顺序流，由主线程按顺序对流执行操作，
     而parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：


stream用并行的流去计算长时间的复杂的计算会有一个影响，用的是jdk自带的公共的线程池
    并行流的设计是为了应对计算密集型的场景的，如果有较多的IO场景，比如常见的RPC调用，在高并发的场景下会导致外部线程阻塞，引起外部线程数增多，
    且这类问题在测试的时候不容易发现，极易引起生产故障。


spring boot自动装配
自己写一个starter
    https://www.cnblogs.com/monkey-xuan/p/15693746.html
jvm常用命令
多数据源@DataSource，线程池
ioc生命周期，主要是mvc的这一套，基于这个去讲
看过dispatchServlet底层，web.xml，启动的核心配置文件，它的起始点从这里开始



easyExcel导入导出
配置中心阿波罗