jvm是如何保证内存分配过程中的线程安全的
    给线程不安全的方法加锁
    线程隔离
        简单来说，就是每个线程在创建的时候，会分配到一块属于自己的内存
        内存大小由jvm当时运行情况计算决定
        这块内存的特殊性就在于，jvm分配内存的时候会优先分配到自己的TLAB中，除此之外的操作都和堆中其他内存块没有区别
怎么保证线程安全
什么是锁，死锁，
    互斥:资源的锁是排他性的，加锁期间只能有一个线程拥有该资源。其他线程只能等待锁释放才能尝试获取该资源。
    请求和保持:当前线程已经拥有至少一个资源，但其同时又发出新的资源请求，而被请求的资源被其他线程拥有。此时进入保持当前资源并等待下个资源的状态。
    不剥夺：线程已拥有的资源，只能由自己释放，不能被其他线程剥夺。
    循环等待：是指有多个线程互相的请求对方的资源，但同时拥有对方下一步所需的资源。形成一种循环，类似2)请求和保持。但此处指多个线程的关系。并不是指单个线程一直在循环中等待。
synchronized原理是什么，怎么用的，锁优化，锁粗化，锁消除，自旋，偏向，轻量级，重量级
synchronized和volatile区别是什么
为什么要用volatile
java内存模型
java并发包有没有什么了解
并发包里failfast，failsafe是怎么回事
什么是copyOnWrite
    Vector是通过对所有操作都加锁的方式实现线程安全的
    从 JDK1.5 开始，Java 并发包提供了两个实现了Copy-On-Write的容器，分别是CopyOnWriteArrayList和CopyOnWriteArraySet
    CopyOnWriteArrayList对add(E e)方法加了同步锁，通过Arrays.copyOf()方法，复制出一个长度为原数组的副本，然后将元素添加到新数组里，最后调用settArray方法，将原数组的引用指向新数组
    读取数据的时候并没有枷锁，如果读的时候正好有其他线程在修改CopyOnWriteArrayList的话，读到的还是旧的数据
    优点：
        读取性能很高，因为读取的时候是无锁的，比较适合读多写少的场景
        采用读写分离策略，允许读取的时候修改集合数据，没有 fail-fast 机制
    缺点：
        内存占用问题，因为CopyOnWrite的写时复制机制，当进行写操作，同时又有线程在读取数据的时候，内存里就会同时驻扎两个对象的内存，如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC
        数据一致性问题，CopyOnWrite只保证数据的最终一致性，并不能保证数据的实时一致性。所以对数据实时一致性要求比较高的场景不适合使用CopyOnWrite容器
什么是aqs，cas
什么是乐观锁，悲观锁，怎么实现的，区别是什么
数据库的锁
什么是行级锁，表级锁，共享锁，排他锁，gap锁，next key lock
数据库的隔离级别
什么是聚簇索引，非聚簇索引
最左前缀
    在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配
索引怎么实现的
hash，b+树
为什么要用b+树
回表

分布式锁是怎么实现的
数据库，redis，zookeeper
这三种实现分布式锁的区别是什么，各自有什么优缺点

分布式缓存
redis和memcach之间有什么区别

zk是怎么实现分布式锁的
什么是zk
什么是CAP理论
为什么CAP不能同时存在
BASE理论
为什么会有BASE理论

分布式系统是怎么保证数据一致性

分布式事务
分布式一致性算法

什么是paxos算法

反射是怎么破坏单例的
    setAccessible(true)
    https://blog.csdn.net/qq_37960603/article/details/104076323

对象的属性拷贝要怎么做？beanUtils是深拷贝还是浅拷贝？
    https://blog.csdn.net/enthan809882/article/details/104956537/
simpleDateFormat是不是线程安全的？多线程情况下会出现什么问题？
    SimpleDateFormat 不是线程安全的，多线程下需要为每个线程创建不同的实例。
    不安全的原因是因为使用了 Calendar 这个全局变量
    calendar.setTime(date)会有线程安全问题

20220515
创建对象的几种方式
    new
    反射
    克隆
    反序列化
new 一个对象的过程
    https://blog.csdn.net/qq_58309291/article/details/123901649
        1.在堆区分配对象需要的内存
        分配内存包括子类和父类的实例变量
        2.对所有实例变量赋默认值
        方法区内对实例变量定义拷贝一份到堆区，赋默认值
        3.执行实例初始化代码
        执行顺序：先初始化父类再初始化子类
        先执行代码在执行构造方法
        4.如果有类似与
        child c=new child（）
        形式的c引用的话，在栈区定义child 类型引用变量c，然后将堆区对象的地址赋值给它。

synchronized怎么保证原子性
    synchronized 底层实际上通过JVM来实现的，同一时间只能有一个线程去执行synchronized 中的代码块。
    原子性：既然同一时间只有一个线程去运行里面的代码，那么这个操作就是不能被其它线程打断的，所以这里天然就具有原子性了。
    保证有序性
        synchronized 遵循as-if-serial语义，不禁止指令重排，不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变
    可见性
        sychronized底层是通过monitorenter的指令来进行加锁的、通过monitorexit指令来释放锁的
        monitorenter指令其实还具有Load屏障的作用。
        也就是通过monitorenter指令之后，synchronized内部的共享变量，每次读取数据的时候被强制从主内存读取最新的数据。
        同样的道理monitorexit指令也具有Store屏障的作用，也就是让synchronized代码块内的共享变量，如果数据有变更的，强制刷新回主内存。


http调用占用内存？异步为什么能减少线程个数？netty，多路复用？netty线程模型？reactor主从
什么场景中使用了redis缓存？缓存中存了用户id？怎么去缓存获取用户id？具体哪个场景中用到了多级缓存？商品详情页，为什么要用多级缓存？
多级缓存：分布式缓存redis+hashmap,hashMap的内存溢出问题有没有？
多级缓存的具体内容
Guava的本地缓存和hashMap实现的本地缓存有什么区别
redis的缓存击穿和穿透的区别？雪崩（随机过期时间)
缓存穿透怎么解决？击穿怎么解决？布隆过滤器
缓存预热？应该怎么做？
用了什么设计模式？模板方法模式、策略模式、单例
Spring getBean获取不同的service,怎么知道自己要获取那个service？
策略服务和key之间的关系是怎么初始化进去的
模板方法有什么不好的地方吗？单例模式被破坏的场景？序列化、反射、对象的拷贝
枚举为什么不能被序列化、反序列化破坏？
反射是怎么破坏单例的？私有的构造函数怎么还能创建对象？
对象的属性拷贝要怎么做？beanUtils是深拷贝还是浅拷贝？apache的beanUtils?
    浅拷贝：创建一个新对象，这个对象对原始对象的属性值有着一份精确的拷贝。如果属性是基本类型数据，拷贝的就是基本类型的值，改变原始数据属性，新对象属性不会发生改变；如果属性是引用类型，那么就是拷贝的这个属性的内存地址，如果属性值发生改变，就会影响到原始对象。
    深拷贝：创建一个新对象，将原始对象从内存中完整的拷贝出来，从堆内存中开辟出一个新的区域存放新对象，且修改新对象，不会影响原始对
看过哪个工具类的源码的实现？时间转换，当前时间+1天，calendar?
date转String类型怎么做?simpleDateFormat，是不是线程安全的?多线程使用会出现什么问题？


分布式锁的实现方式？Lua、redission，锁释放失败了怎么办？重复释放还是失败了怎么办？
key是怎么存的（类名+方法名+资源名），value对比
uuid怎么能保证不重复？时间，max
超时时间到了，任务还没执行完怎么解决，续期
java并发，countDownLatch的机制，怎么保证线程安全？
AQS会加锁吗？CAS
countDownLatch，semaphore和cyclicBarrier区别和联系？
Atomic操作用过吗?longAdder,longAdder能替换掉AtomicInt吗？并发度/实时性？
longAdder的结果一定是准的吗？既然不准什么场景适合用呢？比如网站访问量？点赞量？
什么是跳表？JUC、Redis有用到，跳表的实现方式？
synchronize,原子性、可见性、有序性？
synchronized锁优化？
有序性?指令重排
synchronized可以禁止指令重排吗？
as-if-serial语义
线程池参数怎么配置的？cpu的2倍？


DO/DTO/VO为什么要搞三层？值对象和实体之间的区别是什么？什么东西可以作为值对象？值对象存储有什么缺点吗？聚合根有了解吗？
享元模式？
面向对象怎么理解？
Spring的源码有看过？Spring Bean初始化过程?单例的bean和非单例的有区别吗？单例的bean会有线程安全问题吗？
Spring支持循环依赖吗？bean的注入方式有哪几种？
为什么要三级缓存，二级可以吗？
所有的注入方式都支持循环依赖吗？为什么构造器注入不支持？
想给一个bean初始化加一下操作，怎么做？除了postConstruct还有其他的吗?
init-method、@post、afterPropertiesSet的执行顺序？
Bean初始化之后给bean加一个代理怎么实现？
Spring用了哪些设计模式？工厂、单例、代理、模板
beanFactory和factoryBean区别？
并发和并行的区别？
    当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。
    当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。

垃圾回收线程和用户处理线程？stop the world？JVM是多进程的？
多线程是怎么实现的？线程的状态？阻塞和等待 什么时候进入阻塞，什么时候进入等待，运行，
有没有可能处于运行状态但是没干活？数据越大优先级越高？
多线程之间数据共享、通信


什么叫做接口的幂等？
分布式事务什么场景用了，TCC是什么意思？Try、Confirm、Cancel，如果Cancel也失败了怎么办？TCC有哪些优缺点？
其他的分布式事务方案？
消息中间件的对比和区别？都支持事务消息吗？都支持延时消息吗？顺序消息呢？
rocketMQ如何保证顺序消息？消费者如何保证先消费M1后消费M2?
Rocketmq怎么保证消息不丢？缓存的刷盘机制？
消息中间件能解决什么问题？削峰填谷、解耦、消息的推拉模型？实时性消息堆积？
推的模式还能削峰填谷吗？如何用拉实现的推？怎么知道拉多少消息合适？第一次拉多少合适呢？
消息堆积怎么解决？增加消费的客户端？代码上做一些优化？
如何让接口的RT变得更小？缓存、拆除不必要的操作。
记录流水的动作可以做异步吗？单独搞一张幂等表


工作中用到的并发先关的技术，countDownLatch，线程池，synchronized
线程安全的问题什么情况下会遇到？如果没有共享变量会有线程安全问题吗？
什么是共享变量？如果是方法入参传进来的变量会有线程安全问题吗？
方法入参传进来的一定是局部变量吗？
Java中的传递方式？为什么值传递的会导致外部的参数值也发生改变？
并发的话，会发生什么问题？并发编程的特性：可见性、有序性和原子性分别介绍一下？
可见性的问题为什么会出现？内存模型、主内存、工作内存
操作系统级别有没有可见性的问题？原子性问题怎么发生的？为什么会被打断？Cpu时间片，有序性问题是怎么回事呢？指令重排
Java中怎么避免并发编程问题？volatile保证可见性、有序性
加锁的过程中是怎么同时保证三个特性的？锁的时间片丢了怎么办，有影响吗？
synchronize会加内存屏障吗？synchronized锁的是什么?一定是对象吗？
锁的是对象的什么东西呢？对.class加锁锁的是什么？
什么情况下用了countDownLatch，怎么实现的？CAS？
CyclicBarrier和countDownLatch区别？Java中还有哪些类基于CAS实现的
Atomic是什么场景下使用?和longAdder区别？为什么不精确还要用呢？
分表？数据的查询问题为什么不考虑用搜索引擎实现？
TCP/UDP区别？HTTP都是基于TCP实现的吗？RPC和HTTP的区别？为什么RPC会比HTTP效率高HTTP短链接？
JVM类加载机制，Java中有几种类加载器？
有没有不遵循双亲委派的类加载机制？tomcat为啥要破坏双亲委派？为什么打破双亲委派就能实现隔离？如果公用的类怎么办
双亲委派的过程找，类加载器之间是继承关系吗？怎么实现的？
类的组合？组合和集成之间的优缺点和如何选择？Java中支持多继承吗？为啥不支持？一个类实现了两个接口，并且接口中定义了同一个方法
Java的是什么时候被加载的？加载后的类会被立即初始化吗？内存的开辟是怎么做的？开辟多大的内存呢？内存分配过程中会有线程安全问题吗？
JVM原理是个啥意思？内存结构？本地方法区里面都有什么？常量存在哪？字符串常量池？字符串池中的常量是什么时候进入常量池的？
运行时常量池和字符串常量池是一回事吗？


ureka原理
索引下推
    不使用索引条件下推优化时的查询过程
        获取下一行，首先读取索引信息，然后根据索引将整行数据读取出来。
        然后通过where条件判断当前数据是否符合条件，符合返回数据。
    使用索引条件下推优化时的查询过程
        获取下一行的索引信息。
        检查索引中存储的列信息是否符合索引条件，如果符合将整行数据读取出来，如果不符合跳过读取下一行。
        用剩余的判断条件，判断此行数据是否符合要求，符合要求返回数据。
索引覆盖
    只需要在一颗索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫做索引覆盖
    select id, name, sex from user where name = 'jack';只有name索引,这种就要回标去查sex数据
    select id, name, sex from user where name = 'jack';如果(name,sex)索引，要索引就覆盖了所有要查询的数据，不需要回标

notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程

